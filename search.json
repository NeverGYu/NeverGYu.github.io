[{"title":"链接(link)","url":"/2025/04/20/%E9%93%BE%E6%8E%A5/","content":"1️⃣ 概念\n定义\n链接（linking）是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。\n\n\n执行期\n链接可以执行于编译时(compiletime)，也就是在源代码被翻译成机器代码时。\n链接可以执行于加载时(loadtime)，也就是在程序被加载器(loader)加载到内存并执行时\n链接可以执行于运行时(runtime)，也就是由应用程序来执行。\n\n\n执行对象\n现代计算机，链接是由叫做链接器（linker）的程序自动执行的。\n\n\n\n2️⃣ 编译器驱动程序\n作用\n\n大多数编译系统提供编译器驱动程序(compilerdriver)，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。\nLinux 环境下，我们可以在 shell 中输入如下命令，调用 GCC 驱动程序\ngcc -o prog main.c sum.c\nmain.c和sum.c分别为两个不同的源文件。\n\n\n\n\n示例程序\n  int sum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main()&#123;    int val = sum(array, 2);    return val;&#125;\n\n  int sum(int *a, int n)&#123;    int i, s = 0;        for (i = 0; i &lt; n; i++) &#123;        s += a[i];    &#125;    return s;&#125;\n😈 驱动程序是如何将示例程序从 ASCII码 源文件翻译成可执行目标文件的？\n\n步骤\n驱动程序首先运行 C 预处理器(cpp)，它将 C 的源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i。\n接着，驱动程序运行 C 编译器( cc1 )，它将 main.i 翻译成一个 ASCII 汇编语言文件 main.s\n然后，驱动程序运行汇编器( as )，它将 main.s 翻译成一个可重定位目标文件 main.o。\n最后，驱动程序运行链接器程序( ld )，将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 prog。\n\n\n流程图  \n执行\n要运行可执行文件 prog，我们在 Linux shell  的命令行上输入它的名字\nlinux&gt; ./prog\n\n\nshell 调用操作系统中一个叫做加载器的函数，它将可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。\n\n\n\n\n\n3️⃣ 静态链接（static linker）\n定义（静态链接器）\n输入：一组可重定向目标文件和命令行参数。\n输出：一个完全链接的、可以加载的和运行的可执行目标文件。\n\n\n😈 两个主要任务\n符号解析（symbolresolution）\n可重定向目标文件定义和引用符号。每个符号对应于一个函数、全局变量或静态变量。\n符号解析的目的是将每个符号引用正好和一个符号定义关联起来。\n\n\n重定位（relocation）\n输入的 可重定位目标文件 (.o) 可以看成由多个 section（节）拼起来的：比如代码节 .text、数据节 .data 等。每个节在文件里都是一段连续存放的字节块。\n在生成 .o 时，编译器&#x2F;汇编器只确定节内偏移（从 0 开始计数），并不会确定最终装载地址；因此对外部符号的地址通常先留占位，等链接阶段再填。\n链接器 先为每个符号（函数&#x2F;全局变量等）分配最终地址，然后根据重定位信息，把代码和数据中所有引用该符号的位置改写为正确的地址（或相对偏移），从而让这些引用在最终程序里指向正确的位置。\n链接器 使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。\n\n\n\n\n理解\n基本事实\n一个可重定位目标文件是字节块的集合。\n这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。\n\n\n\n\n\n1️⃣ 目标文件\n形式\n可重定位目标文件：\n包含二进制代码和数据，其形式可以在链接时与其他可重定位目标文件合并起来，创建一个可执行目标文件。\n\n\n可执行目标文件：\n包含二进制代码和数据，其形式可以被直接复制到内存并执行。\n\n\n共享目标文件：\n一种特殊的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。\n\n\n\n\n理解\n编译器和汇编器生成可重定位目标文件；链接器生成可执行目标文件。\n从技术上来说\n目标模块（object mudule）就是一个字节序列。\n目标文件（object file）就是一个以文件形式存放在硬盘的目标模块。\n\n\n\n\n\n2️⃣ 可重定位目标文件\n**ELF**_可重定位目标文件格式\n  \n\n解析\n\n.text：已编译程序的机器代码。\n.rodata：只读数据。\n.data：已初始化的全局和静态 C 变量。\n.bss：未初始化的全局和静态 C 变量，以及初始化为 0 的全局或静态变量。\n.symtab：符号表，它存放在程序中定义和引用的函数和全局变量的信息。\n.rel.text：代码段 .text 的重定位表，它列出 .text 中哪些位置包含“待填的地址&#x2F;位移”。。\n当链接器把这个目标文件和其他文件组合时，需要修改这些位置。\n一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。\n另一方面，调用本地函数的指令则不需要修改。\n\n\n.rel.data：是数据段 .data 的重定位表，它记录 .data 中哪些位置存放了“需要在链接后才能确定的地址值”。\n包含被模块引用或定义的所有全局变量的重定位信息。\n任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。\n\n\n.debug：调试符号表，其条目是程序中定义的局部变量和类型定义。\n保存源代码到机器码的映射关系，以及局部变量&#x2F;类型&#x2F;作用域等信息，供 gdb/lldb 在调试时显示变量、行号和堆栈使用；程序运行本身不依赖它。\n\n\n.line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。\n.strtab：字符串表，其内容保存 .symtab 和 .debug 节中的符号表以及节头部中的节名字。\nELF 头\n以 16 字节的序列开始，描述了生成该文件的系统的字的大小和字节顺序。\nELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。\n\n\n其中包括\nELF 头的大小\n目标文件的类型（如可重定位、可执行或者共享的）\n机器类型（如x86-64）\n节头部表（section header table）的文件偏移\n节头部表中条目的大小和数量——不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry)。\n\n\n\n\n节头部表\n节头部表是 ELF 文件中的一个数组，每个条目描述文件中的一个节。每个节头条目都是一个固定大小的结构，描述该节的类型、位置、大小等信息。\n\n\n\n\n\n3️⃣ 符号\n符号定义\n\n符号定义 指的是在源代码创建一个符号，并为它分配一个内存位置或者给它一个值。\n\n通常，符号定义是对某个变量或函数的声明和赋值，表示这个符号存在于程序中。  \n\n每个符号在程序中只能有一个定义（避免重复定义）。如果有多个定义，链接器会报错。\n  // 定义一个全局变量 xint x = 10;// 定义一个函数 foovoid foo()&#123;    printf(&quot;hello world&quot;);&#125;\n\n\n符号引用\n\n符号引用 指的是在程序中使用某个符号，但是在当前源文件中没有进行定义。  \n符号引用 指的是对其他模块或者外部符号的访问，链接器会根据符号引用找到该符号的定义。\t  // 声明一个外部符号 xextern int x; // 引用全局变量 xvoid bar() &#123;    printf(&quot;%d\\n&quot;, x); &#125;// 声明一个外部函数 fooextern void foo();  void bar() &#123;    foo();  // 引用函数 foo&#125;       \n\n\n符号的种类\n\n由模块 m 定义并能被其他模块引用的全局符号。\n全局符号 对应于非静态的C函数和全局变量。\n\n\n由其他模块定义并被模块 m 引用的全局符号。\n外部符号 对应于在其他模块中定义的非静态C函数和全局变量。\n\n\n只被模块 m 定义和引用的本地符号。\n它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。\n\n\n\n   #include &lt;stdio.h&gt;// 1. 模块 m 定义并能被其他模块引用的全局符号（Global Symbol）int global_var = 100; // 定义了一个全局变量 global_varvoid foo() &#123; // 定义了一个全局函数 foo     printf(&quot;Function foo() called\\n&quot;);&#125;// 2. 只被模块 m 定义和引用的局部符号（Local Symbol with static)static int local_var = 200; // 定义了一个局部符号 local_var，只能在 file1.c 中访问static void bar() &#123; // 定义了一个局部函数 bar，只能在 file1.c 中访问    printf(&quot;Function bar() called\\n&quot;);&#125;\n\n  #include &lt;stdio.h&gt;// 3. 由其他模块定义并被模块 m 引用的全局符号（External Symbol）extern int global_var;  // 引用了在 file1.c 中定义的全局符号 global_varextern void foo();      // 引用了在 file1.c 中定义的全局函数 foo void test() &#123;    printf(&quot;global_var = %d\\n&quot;, global_var); // 使用 global_var    foo(); // 使用 foo&#125;\n\n4️⃣ 符号表符号表定义 每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。\n\n理解\n.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。\n\n定义为带有 static 属性的本地过程变量是不在栈中管理的。相反，编译器在 .data 或 .bss 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。\n  \n\n在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以用 x.1 表示函数 f 中的定义，而用x.2 表示函数 g 中的定义。\n\n\n\n\n符号表的结构符号表是一个包含符号的一维数组，.symtab 节中就包含着 ELF 符号表。\n符号的定义\n\nname 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。\n\nvalue 是符号的地址。对于可重定位的模块来说，value 只表示符号在其所在节（section）内的相对位置——也就是相对于该节起始地址的偏移量。\n\nsize 是目标的大小（以字节为单位）。\n\ntype 通常要么是数据，要么是函数。符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。所以这些目标的类型也有所不同。\n\nbinding 字段表示符号是本地的还是全局的。\n\nsection 字段表示每个符号都被分配到目标文件的某个节，该字段也是一个到节头部表的索引。\n\n有三个特殊的伪节（pseudosection），它们在节头部表中是没有条目的：\nABS代表不该被重定位的符号\nUNDEF代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号\nCOMMON 表示符号是未初始化的数据，链接器会在链接时为其分配内存 。\n\n\n注意\n只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。\n\n\n\n\n例子\n  \n\n解析\n全局符号 main 定义的条目，它是一个位于 .text 节中偏移量为 0 的 24 字节函数。\n全局符号 array 的定义，它是一个位于 .data 节中偏移量为 0 处的 8 字节目标。\n最后一个条目来自对外部符号 sum 的引用。\nREADELF 用整数索引来标识每个节。Ndx=1 表示 .text 节，而 Ndx=3 表示 .data 节。\n\n\n\n\n\n5️⃣ 符号解析定义链接器 解析符号引用的方法是将符号引用和输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。\n解析方式\n对和 引用 定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。\n编译器只允许每个模块中每个局部符号有一个定义。\n静态局部变量会有本地符号，编译器还要确保它们拥有唯一的名字。\n\n\n全局符号的引用解析就棘手得多\n当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。\n\n如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。\n void foo(void);int main() &#123;    foo();    return 0;&#125;\n 编译器可以运行，但是链接器无法解析对 foo 的引用。\n\n\n\n\n链接器如何解析多重定义的全局符号 😈问题\n链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的，有些是全局的。\n如果多个模块定义同名的全局符号，会发生什么呢？\n\n解决方法\n在编译时，编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak）\n而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。\n函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。\n\n链接器处理规则\n规则1：不允许有多个同名的强符号。\n规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。\n规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。\n\n示例代码规则一int main() &#123;    return 0;&#125;        \nint main() &#123;    return 0;&#125;\n这种情况下，链接器将生成一条错误信息，因为强符号 main 被定义了多次（规则1）\n规则二如果在一个模块里 x 未被初始化，那么链接器将安静地选择在另一个模块中定义的强符号(规则2)：\n#include &lt;stdio.h&gt;void f(void);int x = 15213;int main() &#123;    f();    printf(&quot;x = %d\\n&quot;, x);    return 0;&#125;\nint x;void f() &#123;    x = 15212;&#125;\n在运行时，函数 f 将 x 的值由 15213 改为 15212，链接器不会表明它检测到多个 x 的定义。\n规则三如果 x 有两个弱定义，会发生同样的事情\n/* foo4.c */#include &lt;stdio.h&gt;void f(void);int x;int main() &#123;    x = 15213;    f();    printf(&quot;x = %d\\n&quot;, x);    return 0;&#125;\n\n/* bar4.c */int x;void f() &#123;    x = 15212;&#125;\n\n与静态库的链接😈静态库\n迄今，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。\n实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库（static library），它可以用做链接器的输入。\n当链接器构造一个输出的可执行文件时，它只复制静态库里面被应用程序引用的目标模块。\n\n存储位置\n在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。\n存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 .a 标识。\n\n创建静态库\n代码示例\nint addcnt = 0;void addvec(int *x, int *y, int *z, int n) &#123;    int i;                addcnt++;                for (i = 0; i &lt; n; i++)        z[i] = x[i] + y[i];&#125;\n\nint multcnt = 0;void multvec(int *x, int *y,int *z, int n) &#123;    int i;                multcnt++;                for (i = 0; i &lt; n; i++)        z[i] = x[i] * Y[i];&#125;\n\n命令行\n\nlinux&gt; gcc -c addvec.c multvec.c\nlinux&gt; ar rcs libvector.a addvec.o multvec.o\n\n\n静态库的使用\n#include &lt;stdio.h&gt;#include &quot;vector.h&quot;int x[2] = &#123;1, 2&#125;;int y[2]= &#123;3, 4&#125;;int z[2];int main() &#123;    addvec(x, y, Z, 2);    printf(&quot;z = [%d %d]\\n&quot;, z[0], z[1]);    return 0;&#125;\n\n为了创建这个程序的可执行文件，我们要编译和链接输入文件 main.o 和 libvector.a\n\n命令行\n\nlinux&gt; gcc -c main2.c\nlinux&gt; gcc -static -o prog2c main2.o ./libvector.a\n\n\n或者\n\nlinux&gt; gcc -c main2.c\nlinux&gt; gcc -static -o prog2c main2.o -L. -lvector\n\n\n流程图\n  \n\n解析\n\n当链接器运行时，它判定 main2.o 引用了 addvec.o 定义的 addvec 符号，所以复制\taddvec.o 到可执行文件。\n因为程序不引用任何由 multvec.o 定义的符号，所以链接器就不会复制这个模块到可执行文件。\n链接器还会复制 libc.a 中的 printf.o 模块，以及许多 C 运行时系统中的其他模块。\n\n\n\n\n\n链接器如何使用静态库解析引用😈\n定义\n\n在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。\n\n\n再扫描的过程中，链接器维护三个集合且初始时 E、U、D全为空：\n\n可重定位目标文件集合E\n未解析的符号集合U\n已经定义的符号集合D\n\n\n👿 扫描流程\n\n对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。\n如果 f 是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f 中的符号定义和引用，并继续下一个输入文件。\n如果 f 是一个存档文件，那么链接器尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。\n如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 E 中，并且链接器修改 U 和 D 来反映 m 中的符号定义和引用。\n对存档文件中所有的成员目标文件都依次进行这个过程，直到 U 和 D 都不再发生变化。\n此时，任何不包含在 E 中的成员目标文件都被丢弃，而链接器将继续处理下一个输入文件。\n\n\n如果当链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位 E 中的目标文件，构建输出的可执行文件。\n\n\n命令行上的库和目标文件的顺序\n\n问题\n\n在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。\n\n\n示例\n\nlinux&gt; gcc -static ./libvector.a main2.c\n  \n\n\n\n解析\n\n在处理 libvector.a 时，U 是空的，所以没有 libvector.a 中的成员目标文件会添加到 E 中。因此，对 addvec 的引用是绝不会被解析的，所以链接器会产生一条错误信息并终止。\n\n\n\n\n\n6️⃣ 重定位前提\n一旦链接器完成了符号解析，它会确保代码中每个符号引用与它正好唯一的符号定义关联起来。\n这意味着对于每个符号引用（如对全局变量或函数的调用），链接器会在目标模块中查找符号表，找到唯一的符号定义并将它们绑定起来。\n例如，如果 file1.o 中引用了 x，链接器会从 file2.o 中的符号表中找到 x 的定义，完成符号解析，并将引用解析到正确的地址。\n\n定义\n链接器如果知道它的输入目标模块中的代码节和数据节的确切大小，然后就可以开始 ”重定位“ 步骤。\n在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。\n\n步骤 😈\n重定位 “节” 和 “符号定义”\n这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。\n例如\n来自所有输入模块的 .data 节被全部合并成一个节，这个节成为输出的可执行目标文件的 .data 节。\n\n\n然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。\n每个节的地址保存在节头部表中，符号的地址保存在符号表中。\n当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。\n\n\n重定位 ”节“中的 ”符号引用“\n这一步中，链接器修改 ”代码节“和 ”数据节“ 中对每个符号的引用，使得它们指向正确的运行时地址。\n执行这一步，链接器依赖于可重定位目标模块中称为重定位条目 的数据结构。\n\n\n\n重定位条目\n前提\n\n当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。\n所以，汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。\n**.rel.text**：包含与代码段（.text 节）相关的重定位条目。这些条目描述了代码中对外部符号的引用位置（例如函数调用或跳转）。\n**.rel.data**：包含与数据段（.data 节）相关的重定位条目。这些条目描述了数据中对外部符号的引用位置（例如全局变量引用）。\n\n\nELF重定位条目格式\n  \n\noffset：是需要被修改的符号引用的节偏移。\nsymbol：标识被修改符号引用应该指向的符号。\ntype：告知链接器如何修改新的引用。\naddend：是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。\n\n\n😈 代码示例\n  extern int global_var;  // 引用外部变量void foo() &#123;       printf(&quot;%d\\n&quot;, global_var);  // 需要链接器来处理地址&#125;\n  int global_var = 42;  // 定义外部变量\n\n\n汇编过程\n汇编器将 file1.o 中的 global_var 引用视为一个符号引用。它并不知道 global_var 在内存中的地址，因为这个地址在编译时是未定义的，因此汇编器为 global_var 生成一个重定位条目，告诉链接器该符号在代码中的位置（即 foo() 函数中引用 global_var 的位置）。  \n汇编器也会为 file2.o 生成目标文件，其中包含对 global_var 的定义，但汇编器不会生成重定位条目，因为它已经知道 global_var 的地址（这是由 file2.o 中的定义提供的）。\n\n\n链接过程\n链接器将 file1.o 和 file2.o 合并成一个最终的可执行文件。\n在合并过程中，链接器检查 file1.o 中的重定位条目（在 .rel.text 节中），并将       global_var 的地址更新为在 file2.o 中定义的实际地址。\n假设 file2.o 中定义的 global_var 的地址是 0x1000，链接器会将 file1.o 中 global_var 的引用地址更新为 0x1000。\n\n\n\n\n\n7️⃣ 可执行目标文件\nELF 可执行目标文件格式\n  \n\n格式解析\nELF 头描述文件的总体格式。它还包括程序的入口点(entrypoint)，也就是当程序运行时要执行的第一条指令的地址。\n.text、.rodata 和 .data 节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。\n.init 节定义了一个小函数，叫做 _init，程序的初始化代码会调用它。\n因为可执行文件是完全链接的（已被重定位），所以它不再需要 .rel 节。\n\n\n理解\nELF 可执行文件被设计得很容易加载到内存，可执行文件的连续的片被映射到连续的内存段。\n\n程序头部表(programheader table)描述了这种映射关系。\n\n示例\n  \n  \n\n解析\n从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。\n第1、2行表明第一个段（代码段）有读&#x2F;执行访问权限，开始于内存地址 0x400000 处，总共的内存大小是 0x69c 字节，并且被初始化为可执行目标文件的头 0x69c个 字节，其中包括 ELF 头、程序头部表以及 .init、.text 和 .rodata 节。\n第3、4行表明第二个段（数据段）有读&#x2F;写访问权限，开始于内存地址0x600df8处，总的内存大小为 0x230 字节，并用从目标文件中偏移 0xdf8 处开始的 .data 节中的 0x228 个字节初始化。该段中剩下的8个字节对应于运行时将被初始化为 0 的 .bss数据。\n\n\n\n\n注意\n\n对于任何段s，链接器必须选择一个起始地址vaddr，使得：  vaddr mod align = off mod align  这里，off是目标文件中段的第一个节的偏移，align是程序头部指定的对齐。\n\n在上图中的data segment\n\nvaddr mod align = 0x600df8 mod 0x200000 = 0xdf8\noff mod align = 0xdf8 mod 0x200000 = 0xdf8\n\n\n\n\n\n\n\n\n\n8️⃣ 加载可执行目标文件\n前提\n\n要运行可执行目标文件prog，我们可以在Linux shell的命令行中输入它的名字：  linux&gt; ./prog\n\n\n解析\n\n因为 prog 不是一个内置的shell命令，所以 shell 会认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行它。\n任何 Linux 程序都可以通过调用 execve 函数来调用加载器。\n加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。\n\n\n虚拟内存\n  \n\n当加载器运行时，它创建类似于上图所示的虚拟内存。\n在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。\n接下来，加载器跳转到程序的入口点，也就是 _start 函数的地址。该函数位于系统目标文件 ctrl.o 中。对所有的C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。\n\n\n\n","categories":["计算机基础","链接"],"tags":["编译器","链接器","ELF"]},{"title":"解谜 extern \"C\"","url":"/2025/05/08/C++%E5%85%AB%E8%82%A1/extern%20C/","content":"1️⃣ 作用以及用途\nextern &quot;C&quot; 的主要作用就是为了能够正确实现C++代码调用其他C语言代码。\n加上 extern &quot;C&quot; 后，会指示编译器这部分的代码按C语言，而不是C++的方式进行编译。\n\n2️⃣ 底层理由\n由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名。\n而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。\n例如函数void fun(int, int)编译后的可能是 _fun_int_int—-不同编译器可能不同，但都采用了相似机制，用函数名和参数类型来命名编译后的函数名；\n而C语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun这样的名字。\n\n因此，如果不加 extern &quot;c&quot;，在链接阶段，链接器会从 moduleA 生成的目标文件 moduleA.obj 中找 _fun_int_int 这样的符号，显然这是不可能找到的，因为 fun() 函数被编译成了_fun 的符号，因此会出现链接错误。\n3️⃣ 代码示例\n模块A的头文件以及源文件  #ifndef __MODULE_A_H #define __MODULE_A_Hint fun(int, int);#endif-----------------------------------------#include &quot;moduleA&quot;int fun(int a, int b)&#123;return a+b;&#125;\n模块B的头文件以及源文件  #ifndef __MODULE_B_H #define __MODULE_B_H#ifdef __cplusplus      //这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件----cpp文件默认定义了该宏),                        // 则采用C语言方式进行编译extern &quot;C&quot;&#123; #include&quot;moduleA.h&quot;#endif···                 //其他代码#ifdef __cplusplus&#125;#endif#endif-----------------------------------------#include&quot;moduleB.h&quot;int main()&#123;　　cout&lt;&lt;fun(2,3)&lt;&lt;endl;&#125;\n\n原文链接：https://blog.csdn.net/qq_28087491/article/details/116595151\n","categories":["C++基础","C++八股"],"tags":["C++八股"]},{"title":"std::jthread和停止令牌","url":"/2025/06/01/C++20/jthread%E5%92%8C%E5%81%9C%E6%AD%A2%E4%BB%A4%E7%89%8C/","content":"1️⃣ 添加 std::jthread 的动机std::thread的缺点缺点一\nstd::thread要求在其生命周期结束时，若表示正在运行的线程，则调用join()（等待线程结束）或detach()（让线程在后台运行）。\n若两者都没有调用，析构函数会立即导致异常的程序终止（在某些系统上导致段错误）。\n\n由于这个原因，下面的代码会出现错误（除非不关心程序异常的终止）\n  void foo()&#123;    std::thread t&#123;task, name, val&#125;;&#125;\n当没有调用join()或detach()就表示正在运行的线程t在析构时，程序会调用std:terminate()，后者调用std::abort()。\n\n\n\n\n缺点二\n即使使用join()来等待正在运行的线程结束，任然会有一个严重的问题  void foo()&#123;    std::thread t&#123;task, name, val&#125;;    ...    t.join();&#125;\n\n这段代码还可能导致程序异常终止，线程开始和调用join()之间的foo()之间的代码发生异常时（或者控制流从未到达join()），就没有调用t.join()。\n\n\n常规解决方案  void foo ()&#123;    ...    std::thread t(task, name, val);    try &#123;        ...    &#125;    catch (...)     &#123;        t.join();         throw;     &#125;    t.join() ;    ...&#125;\n\n这里，通过确保在离开作用域时调用join()来对异常作出反应，而不解决异常。\n不幸的是，这可能会导致阻塞（永远）。\n调用detach()也是一个问题，因为线程在程序的后台继续运行，使用CPU时间和资源，而这些时间和资源现在可能会销毁。\n\n\n若在更复杂的上下文中使用多个线程，问题会变得更糟，并且会产生非常糟糕的代码。  void foo()&#123;    std::thread tl(taskl, name, val);    std::thread t2;    try &#123;        t2 = std::thread(task2, name, val);    &#125;    catch (...)     &#123;         t1.join();         if (t2.joinable())         &#123;             t2.join();        &#125;        throw;     &#125;    t1.join() ;    t2.join() ;    ...&#125;\n\n启动第一个线程之后，启动第二个线程可能会抛出异常，因此启动第二个线程必须在try子句中进行。\n另一方面，可在同一范围内使用和join()两个线程。为了满足这两个需求，必须前向声明第二个线程，并在第一个线程的try子句中对其进行赋值。\n此外，对于异常，必须检查第二个线程是否启动，对没有关联线程的线程对象调用join()会导致异常。  另一个问题是，对两个线程调用join()可能会花费大量时间（甚至永远）。\n\n\n注意，不能 “杀死” 已经启动的线程。线程不是进程，线程只能通过结束自身或结束整个程序来结束。\n\n\n\n使用 std::jthread\nstd::jthread解决了这些问题，它是RAII类型。若线程是可汇入的（“j” 代表 “汇入”），析构函数会自动调用join()。这让上面的复杂代码变简单了：\n  void foo ()&#123;    // start thread calling taskl() with name and val as arguments:    std::jthread tl(taskl, name, val);    // start thread calling task2 () with name and val as arguments:    std::jthread t2(task2, name, val);    // wait for threads to finish:    t1.join();    t2.join();&#125;\n\n使用std::jthread就不再存在导致异常程序终止的危险，也不需要异常处理。\n为了支持尽可能容易地切换到std:jthread类，该类提供了与std:thread相同的 API，包括:\n使用相同的头文件&lt;thread&gt;\n当调用get_id()时返回std:thread:id(std:jthread::id类型只是一个别名类型)\n提供静态成员hardware_concurrency()\n\n\n只需用std:jthread替换std:thread并重新编译，代码就会变得更安全。\n\n\n\nstd::jthread更多的特性停止令牌和停止回调\n类std:jthread做的更多：提供了一种使用 停止令牌 发出取消信号的机制，这些令牌由jthread的析构函数在调用join()之前使用，由线程启动的可调用对象（函数、函数对象或Lambda）必须支持此请求:\n\n若可调用对象只为所有传递的参数提供参数，将忽略停止请求：  void task (std::string S, double value)&#123;    ... // join() waits until this code ends&#125;\n为了响应停止请求，可调用对象可以添加一个新的可选第一个类型为std:stop_token的参数，并不时检查是否请求了停止：  void task (std::stop_token st,std::string s, double value)&#123;    while (!st.stop_requested()) // stop requested (e.g., by the destructor)?    &#123;        ... // ensure we check from time to time    &#125;&#125;\n\n\n所以，std::jthread提供了一种 协作机制 来表示线程不应该再运行。它是 “协作的” ，因为该机制不会杀死正在运行的线程（因为C++线程根本不支持杀死线程，所以杀死线程的操作可能很容易使程序处于损坏状态）。为了响应停止请求，已启动的线程必须声明停止令牌作为附加的第一个参数，并使用它不时的检查是否应该继续运行。也可以手动请求已经启动的jthread停止。例如：\n  void foo()&#123;    // start thread calling task() with name and val as arguments:    std::jthread t(task, name, val);    if(...)    &#123;        t.request_stop();    &#125;    ...    // wait for thread to finish:    t.join();    ...       &#125;\n此外，还有另一种对停止请求作出反应的方法：可以为停止令牌注册回调，该回调将在请求停止时自动调用：\n  void task (std::stop_token st,std::string S, double value)&#123;    std::stop_callback cb&#123;st, [] &#123;            ...         // called on a stop request            &#125;&#125;;    ...&#125;\n因此，停止执行task()线程的请求（无论是显式调用request_stop()还是由析构函数引起）都会调用注册为停止回调的lambda。\n\n请注意，回调通常由请求停止的线程调用。\n停止回调函数cb的生命周期结束时，析构函数自动注销回调函数，以便在之后发出停止信号时不再调用该回调函数，也可以通过这种方式注册任意数量的可调用对象（函数、函数对象或Lambda）。\n停止机制比最初看起来更灵活：\n可以传递句柄来请求停止，并传递令牌来检查请求的停止。\n支持条件变量，这样一个有信号的停止就可以中断一个等待。\n也可以独立于std:jthread使用这种机制来请求和检查停止。\n\n\n\n\n线程、停止源、停止令牌和停止回调之间也没有生命周期约束，存储停止状态的位置在堆上分配。当线程和使用此状态的最后一个停止源、停止令牌或停止回调函数销毁时，用于停止状态的内存将释放。\n\n\n停止令牌和条件变量\n当请求停止时，线程可能会因等待条件变量的通知而阻塞。\n停止令牌的回调接口也支持这种情况。可以使用传递的停止令牌为条件变量调用 wait()，以便在请求停止时暂停等待。\n由于技术原因，必须使用 std::condition_variable_any 类型作为条件变量。  include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;stop_token&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;using namespacestd::literals; // for duration literalsint main()&#123;    std::queue&lt;std::string&gt; messages;    std::mutex messagesMx;    std::condition_variable_any messagescv;    // start thread that prints messages that occur in the queue:    std:jthread tl&#123; [s] (std:stop_token st)&#123;        while (Ist.stop_requested())        &#123;            std::string msg;            &#123;                // wait for the next message:                std::unique_lock lock(messagesMx);                if (!messagescv.wait(lock, st,[&amp;] &#123;                    return Imessages.empty();&#125;))                &#123;                    return; // stop requested                &#125;                      // retrieve the next message out of the queue:                msg - messages.front();                messages.pop () :            &#125;            // print the next message:            std::cout &lt;&lt; &quot;msg: &quot; &lt;&lt; msg &lt;&lt; std::endl,        &#125;    &#125;&#125;;       // store 3 messages and notify one waiting thread each time:    for (std::string s : (&quot;Tic&quot;, &quot;Tac&quot;, &quot;Toe&quot;))     &#123;        std:scoped_lock Ig(messagesMx);        messages.push(s);        messagesCv.notify_one();     &#125;    // after some time    // - store l message and notify all waiting threads:    std::this_thread::sleep_for(ls);    &#123;        std::scoped_1ock Ig(messagesMx);        messages.push(&quot;done&quot;);        messagesCV.notify_all();    &#125;        // after some time    //- end program (requests stop, which interrupts wait())    std::this_thread::sleep_for(ls);&#125;\n\n\n用停止令牌调用 wait()，在这里传递停止令牌信号来停止线程，所以wait现在可能会结束的原因有两个:\n一个通知 (队列不再为空)\n要求停止\n\n\nwait() 的返回值表示是否满足条件。若返回 false，则结束 wait() 的原因是请求停止，则可以做出相应的反应。\n\n2️⃣ 停止来源和停止令牌基本概念\nC++20 不仅为线程提供了停止令牌。它是一种通用机制，可以异步请求停止，并使用各种方式对该请求作出响应。\n\n机制\nC++20 标准库可创建一个共享的停止状态。默认情况下，停止状态不会发出信号。\n类型为 std::stop_source 的停止源可以在其关联的共享停止状态下请求停止。\nstd::stop_token 类型的停止令牌可用于，在其关联的共享停止状态下响应停止请求\n可以主动轮询是否请求了停止\n或者注册一个类型为 std::stop_callback 的回调，该回调将在请求停止时调用。\n\n\n当停止请求发出，就不能撤销 (后续的停止请求无效)。\n可以复制和移动停止源和停止令牌，允许在代码的多个位置发出停止信号或对停止做出反应。\n复制源代码或令牌的成本相对较低，因此按值传递可避免生命周期问题。\n然而，复制并不像传递整型值或原始指针那么简单，更像是传递一个共享指针。若经常将其传递给子函数，那么通过引用传递可能会更好。\n\n\n该机制是线程安全的，可以在并发情况下使用。停止请求、检查请求的停止，以及对注册或取消注册的回调调用需要同步，并且当最后一个用户 (停止源、停止令牌或停止回调) 销毁时，关联的共享停止状态将自动销毁。\n\n创建停止源和停止令牌 #include &lt;stop_token&gt;// create stop_source and stop_token:std::stop_source ssrc; // creates a shared stop statestd::stop_token stok&#123;ssrc.get_token()&#125;; // creates a token for the stop state\n\n第一步是简单地创建 stop_source 对象，该对象提供了请求停止的 API。构造函数还创建关联的共享停止状态，就可以向停止源请求 stop_token 对象，该对象提供对停止请求作出反应的 API(通过轮询或注册回调)。\n然后，可以将令牌 (或源) 传递给位置&#x2F;线程，以在可能请求停止的位置和可能对停止做出反应的位置之间建立异步通信。\n没有其他方法可以创建具有关联的共享停止状态的停止令牌，停止令牌的默认构造函数没有关联的停止状态。\n\n停止源和停止令牌的详情停止源的详情","categories":["C++基础","C++20"],"tags":["C++20"]},{"title":"指针与引用","url":"/2025/12/20/C++%E5%85%AB%E8%82%A1/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/","content":"1️⃣ 指针什么是指针？指针： 指向另外一种类型的复合类型。\n指针的大小及用法？在 64 位计算机中，指针占 8 个字节空间。\n#include&lt;iostream&gt;using namespace std;int main()&#123;    int *p = nullptr;    cout&lt;&lt;sizeof(p)&lt;&lt;endl;  // 8    char *p1= nullptr;    cout&lt;&lt;sizeof(p1)&lt;&lt;endl; // 8    return 0;&#125;\n指针的用法\n指向普通对象的指针\n常量指针\n函数指针\n指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。\nthis 指针：指向类的当前对象的指针常量。\n\n什么是野指针和悬空指针？\n悬空指针\n\n若指针指向一块内存空间\n当这块内存空间被释放后，该指针依然指向这块内存空间\n此时，称该指针为”悬空指针”。\n\nvoid *p = malloc(size);free(p); // 此时，p 指向的内存空间已释放， p 就是悬空指针。\n野指针\n\n不确定其指向的指针，未初始化的指针为“野指针”\n\nvoid *p; // 此时 p 是“野指针”。\n\n常量指针和指针常量的区别是什么？\n常量指针\n常量指针本质上是个指针，只不过这个指针指向的对象是常量。\nconst 的位置在指针声明运算符 * 的左侧。\n指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。\n三个特点\none\nconst int * p;int const * p;\n\ntwo\n#include &lt;iostream&gt;using namespace std;int main()&#123;    const int c_var = 8;    const int *p= &amp;c_var;    *p=6;    // error: assignment of read-only location&#x27;*p&#x27;    return 0;&#125;\nthree\n#include &lt;iostream&gt;using namespace std;int main()&#123;    const int c_var1= 8;    const int c_var2 = 8;    const int *p = &amp;c_var1;    p= &amp;c_var2;    return 0;&#125;\n\n\n\n\n指针常量\n指针常量的本质上是个常量，只不过这个常量的值是一个指针\nconst 位于指针声明操作符右侧，表明该对象本身是一个常量\n三个特点\none\nint var;int * const c_p = &amp;var;\ntwo \n#include&lt;iostream&gt;using namespace std;int main()&#123;    int var,varl;    int * const c_p = &amp;var;    c_p = &amp;var1;    // error: assignment of read-only variable &#x27;c_p&#x27;    return 0;&#125;\nthree\n#include&lt;iostream&gt;using namespace std;  int main()&#123;    int var = 3;    int * const c_p = &amp;var;    *c_p = 12;    return 0;&#125;\n\n\n\n\n\n指针函数和函数指针的区别是什么？\n指针函数\n\n指针函数本质是一个函数，只不过该函数的返回值是一个指针。\n#include&lt;iostream&gt;using namespace std;struct Type&#123;    int varl;    int var2;&#125;;Type* fun(int tmpl, int tmp2)&#123;    Type* t = new Type();    t-&gt;var1 = tmp1;    t-&gt;var2 = tmp2;    return t;&#125;int main()&#123;    Type *p = fun(5，6);    return 0;&#125;\n\n\n函数指针\n\n函数指针本质是一个指针变量，只不过这个指针指向一个函数。\n#include &lt;iostream&gt;using namespace std;int fun1(int tmpl,int tmp2)&#123;    return tmp1 * tmp2;&#125;int fun2(int tmp1,int tmp2)&#123;    return tmp1 / tmp2;&#125;int main()&#123;    int (*fun)(int x,int y);    fun = fun1;    cout &lt;&lt; fun(15，5) &lt;&lt; endl;    fun= fun2;    cout &lt;&lt; fun(15，5) &lt;&lt; endl;    return 0;&#125;\n\n\n\n2️⃣ 指针和引用的区别\n指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）\n指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）\n指针可以为空，但是引用必须绑定对象。（是否可为空）\n指针可以有多级，但是引用只能一级。（是否能为多级）\n\n“引用” 的底层实现原理详解案例引入#include&lt;iostream&gt;using namespace std;int main()&#123;\tint  a = 1;\tint&amp;  b = a;\tcout &lt;&lt; &quot;a:address-&gt;&quot; &lt;&lt; &amp;a &lt;&lt; endl;\tcout &lt;&lt; &quot;b:address-&gt;&quot; &lt;&lt; &amp;b &lt;&lt; endl;\t\tgetchar();\treturn 0;&#125;\n运行结果a:address-&gt;0031FD54b:address-&gt;0031FD54\n现象？\n我们发现引用 b 的地址和变量 a 的地址是一样的。\n可能有人会猜想：是不是说变量 a 和引用 b 本身就是一个东西。所以同样的，引用本身所占内存就是变量的内存。\n首先对于这个说法，肯定是不正确的， 至于为什么不正确，我们接下来会以底层原理为大家解释。\n\n原理\n案例代码\n  #include&lt;iostream&gt;using namespace std;int main()&#123;    int x=1;    int &amp;b=x;    return 0;&#125;\n上述代码转汇编后的汇编代码\n  9:       int x = 1; \t//源代码 00401048   mov         dword ptr [ebp-4],1\t//反汇编代码  10:      int &amp;b = x; \t//源代码0040104F   lea         eax,[ebp-4]  \t\t//反汇编代码00401052   mov         dword ptr [ebp-8],eax//反汇编代码\n\n解释\n上述三行代码的作用就是将 1 赋值给 x，然后将 x 的地址赋值给了引用 b。\n\n\n\n\n\n\n底层分析\n\n引用的本质就是所引用对象的地址\n通俗点理解就是引用就是通过指针来实现的\n引用所占的内存大小就是指针的大小。\n\n\n为什么在测试代码中，引用的地址和变量的地址是一样的？\n\n事实上， b 的地址我们没法通过 &amp;b 获得。\n因为编译器会将 &amp;b 解释为：&amp;(*b) = &amp;x,所以 &amp;b 将得到 &amp;x。\n\n\n\n3️⃣指针、引用与值传递指针、引用与值传递的区别？\n值传递\n值传递是指将参数的值复制一份，传递给函数或方法进行操作。\n在值传递中，函数或方法对参数进行修改不会影响到原始的变量值。\n\n\n指针与引用\n指针和引用是指将参数的内存地址传递给函数或方法，使得函数或方法可以直接访问和修改原始变量的值。\n在指针和引用中，函数或方法对参数的修改会直接反映在原始变量上。\n\n\n\n函数传参用引用的优点是什么？\n可以避免避免拷贝，使用引用传参可以避免对大型对象进行复制。\n如果传递一个对象作为值参数，会触发对象的拷贝构造函数，造成额外的开销。\n而使用引用传参，可以直接在函数中操作原始对象，避免了拷贝操作。\n\n参数传递时，值传递、引用传递、指针传递的区别？\n参数传递的三种方式\n\n值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。\n指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。\n引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。\n\n\n案例代码\n  #include &lt;iostream&gt;using namespace std;void fun1(int tmp) &#123; // 值传递    cout &lt;&lt; &amp;tmp &lt;&lt; endl;&#125;void fun2(int * tmp)&#123; // 指针传递    cout &lt;&lt; tmp &lt;&lt; endl;&#125;void fun3(int &amp;tmp)&#123; // 引用传递    cout &lt;&lt; &amp;tmp &lt;&lt; endl;&#125;int main()&#123;    int var = 5;    cout &lt;&lt; &quot;var 在主函数中的地址：&quot; &lt;&lt; &amp;var &lt;&lt; endl;    cout &lt;&lt; &quot;var 值传递时的地址：&quot;;    fun1(var);    cout &lt;&lt; &quot;var 指针传递时的地址：&quot;;    fun2(&amp;var);    cout &lt;&lt; &quot;var 引用传递时的地址：&quot;;    fun3(var);    return 0;&#125;\n运行结果\n  var 在主函数中的地址：0x23fe4cvar 值传递时的地址：0x23fe20var 指针传递时的地址：0x23fe4cvar 引用传递时的地址：0x23fe4c\n\n参考资料：\n小林 coding\nc++中“引用”的底层实现原理详解\n","categories":["C++基础","C++八股"],"tags":["C++八股","指针与引用"]},{"title":"条款04：确定对象被使用前已先被初始化","url":"/2025/04/25/effective_c++/04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"1️⃣ 问题引入\n在不同的语境下，对象是否会被初始化时不一定的 ！\nint x;\n如果 x是全局变量，则会被初始化为 0 ; 如果 x是局部变量，则不会被初始化。\n\n\n类相关class Point&#123;  int x , y;&#125;···Point P;\n\n同理的，p的成员变量有时候被初始化为 0，有时候不会。\n\n\n为什么要初始化对象 ?\n读取未初始化的值会导致不明确的行为。\n在某些平台上，仅仅只是读取未初始化的值，就可能让你的程序终止运行。\n\n\n\n2️⃣ 最佳处理方式\n规则一：永远在使用对象之前就先将它初始化\n对于内置类型，必须手工完成 ；对于类而言，初始化的责任就落在构造函数将对象的每一个成员都初始化。\n\n\n规则二：总是在成员初值列中列出所有的变量，使得记住还有哪些成员变量。\n\n3️⃣ 别混淆  “赋值”  和 “初始化”\n案例引入class PhoneNumber &#123;... &#125;;class ABEntry   //ABEntry = &quot;Address Book Entry&quot;&#123;   public:  ABEntry(const std::string&amp; name, const std::string&amp; address,  const std::list&lt;PhoneNumber&gt;&amp;phones);private:  std::string theName;  std::stringtheAddress;  std::list&lt;PhoneNumber&gt;thePhones;  int numTimesConsulted;&#125;;ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address,const std::list&lt;PhoneNumber&gt;&amp;phones)&#123;  theName = name;         //这些都是赋值（assignments），  theAddress = address;   //而非初始化（initializations)。  thePhones = phones;  numTimesConsulted = 0;&#125;\n解析\n这会导致ABEntry对象带有指定的值，但却不是最佳做法。\n原因\nC++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前 。\n在ABEntry构造函数内，theName，theAddress和thePhones都不是被初始化，而是被赋值 。\n初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之时，比进入ABEntry构造函数本体的时间更早 。\n但这对numTimesConsulted不为真，因为它属于内置类型，不保证一定在你所看到的那个赋值动作的时间点之前获得初值 。\n\n\n\n\n最佳写法\n使用 member initialization list 替换复制动作 。ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address,const std::list&lt;PhoneNumber&gt;&amp;phones): theName(name),          //现在，这些都是初始化（initializations)  theAddress(address),  thePhones(phones),  numTimesConsulted(0)&#123;&#125;                        //现在，构造函数本体不必有任何动作\n构造函数和上一个的最终结果相同，但通常效率较高。\n原因\n赋值版本\n首先调用default构造函数为theName，theAddress和thePhones设初值， 然后再调用copy assignment 。\n\n\n成员初始化版本\n初值列中针对各个成员变量而设的实参，被拿去作为各成员变量之构造函数的实参。\n本例中的theName以name为初值进行copy构造，theAddress以address为初值进行copy构造，thePhones以phones为初值进行copy构造。\n\n\n\n\n\n\n\n4️⃣ 成员初始化次序\n定义\nC++中有着十分固定的 “成员初始化次序” 。\n\n\n次序\nbase classes更早于其derived classes被初始。\nclass的成员变量总是以其被初始化。\n\n\n\n5️⃣ 不同编译单元定义的 “ 非局部静态变量” 的初始化次序\nstatic对象\n定义\n所谓static对象，其寿命从被构造出来直到程序结束为止，因此stack和heap-based对象都被排除。\n\n\n种类\nlocal static对象    &lt;——&gt; 函数内的static对象\nnon-localstatic对象 &lt;——&gt; 非函数内的static对象。\n\n\n生命周期\n程序结束时static对象会被自动销毁，也就是它们的析构函数会在main()结束时被自动调用。\n\n\n\n\n编译单元\n是指产出 ”单一目标文件“ 的 ”源码“ 文件。\n\n\n\n关心的问题\n涉及两个源码文件，每一个内含至少一个non-local static。\n\n关键的原因\n\n如果某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元内的某个non-localstatic对象，它所用到的这个对象可能尚未被初始化，因为C++对定义于不同编译单元内的non-localstatic对象”的初始化次序并无明确定义。\n\n\n案例引入\nclass FileSystem &#123;public:    ···    std::size_t numDisks () const;      //众多成员函数之一    ···&#125;;extern FileSystem tfs;      //预备给客户使用的对象；                            //tfs代表&quot;the file system&quot;\nFileSystem对象绝不是一个稀松平常无关痛痒的(trivial)对象，因此你的客户如果在theFileSystem对象构造完成前就使用它，会得到惨重的代价。\n现在假设某些客户建立了一个class用以处理文件系统内的目录（directories）。很自然他们的class会用上theFileSystem对象：\nclass Directory    //由程序库客户建立&#123;    public:    Directory(params);&#125;;Directory:: Directory(params);std::size_t disks = tfs.numDisks();     //使用tfs对象\n进一步假设，这些客户决定创建一个Directory对象，用来放置临时文件\nDirectory tempDir(params);    //为临时文件而做出的目录\n😈😈😈\n现在，初始化次序的重要性显现出来了\n\n除非tfs在tempDir之前先被初始化，否则tempDir的构造函数会用到尚未初始化的tfs。但tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的non-localstatic对象。如何能够确定tfs会在tempDir之前先被初始化?\n\n\n原理\n\n无法确定，因为C++对 “定义于不同的编译单元内的non-localstatic对象” 的初始化相对次序并无明确定义。\n这是有原因的：决定它们的初始化次序相当困难，非常困难，根本无解。\n在其最常见形式，也就是多个编译单元内的non-local static对象经由“模板隐式具现化，implicit template instantiations”形成（而后者自己可能也是经由“模板隐式具现化”形成），不但不可能决定正确的初始化次序，甚至往往不值得寻找“可决定正确次序”的特殊情况。\n\n\n解决措施\n\nSingleton 模板的实现\nC++保证，函数内的local static对象会在 “该函数被调用期间” “首次遇上该对象之定义式”时被初始化。所以如果你以“函数调用”（返回一个reference指向local static对象）替换“直接访问non-local static对象”，你就获得了保证，保证你所获得的那个reference将指向一个历经初始化的对象。更棒的是，如果你从未调用non-local static对象的“仿真函数”，就绝不会引发构造和析构成本；真正的non-local static对象可没这等便宜！\n\n\n\n\n\n","categories":["C++基础","effective c++"],"tags":["Effective C++"]},{"title":"条款05：了解C++默默编写时调用了什么函数","url":"/2025/04/20/effective_c++/05%EF%BC%9A%E4%BA%86%E8%A7%A3%20C++%20%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E6%97%B6%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0/","content":"1️⃣ 问题引入\n当定义一个 empty class 会发生什么？\n编译器会为这个 empty class 自动声明：\ncopy 构造函数\ncopy assignment 操作符\n析构函数\n\n\n同理，如果没有定义任何构造函数，编译器也会声明一个 default 默认构造函数。\n\n2️⃣ 案例class Empty &#123;&#125;;\n\n等价于：\nclass Empty &#123;public:    Empty() &#123; ... &#125;    Empty(const Empty&amp; rhs) &#123; ... &#125;    Empty&amp; operator=(const Empty&amp; rhs) &#123; ... &#125;    ~Empty() &#123; ... &#125;&#125;;\n\n3️⃣ 产生时机\n只有这些函数被调用的时候，它们才会被编译器创建出来。\n\nEmpty e1;           // default构造函数 + 析构函数Empty e2(e1);       // copy构造函数e2 = e1;            // copy assignment操作符\n\n4️⃣ 对于拷贝的理解\n浅拷贝：\n对于 copy 构造函数、copy assignment 操作符，编译器创建的版本只是将来源对象的每一个非静态成员变量拷贝到目标对象。\n\n\n\n案例：template&lt;typename T&gt;class NamedObject &#123;public:    NamedObject(const char* name, const T&amp; value);    NamedObject(const std::string&amp; name, const T&amp; value);private:    std::string nameValue;    T objectValue;&#125;;\n\n\nNamedObject 没有声明 copy 构造函数，也没有声明 copy assignment 操作符。\n如果发生如下代码，会怎么样？\n\nNamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2);NamedObject&lt;int&gt; no2(no1);\n\n解析：\n编译器生成的 copy 构造函数将以 no1.nameValue 和 no1.objectValue 为初值，设定 no2 对应的两个成员。\nnameValue 是 std::string 类型，会调用 string 的 copy 构造函数。\nobjectValue 是 int 类型（T &#x3D; int），为内置类型，因此会直接拷贝 bits。\n\n5️⃣ 对于 copy assignment 的理解\n一般情况下，copy assignment 操作符和 copy 构造函数相似。\n但有时，编译器会拒绝为某些类生成 copy assignment 操作符。\n\n案例：template&lt;class T&gt;class NamedObject &#123;public:    NamedObject(std::string&amp; name, const T&amp; value);private:    std::string&amp; nameValue; // 这是个 reference    const T objectValue;    // 这是个 const&#125;;\n\n如果执行如下代码：\nstd::string newDog(&quot;Persephone&quot;);std::string oldDog(&quot;Satch&quot;);NamedObject&lt;int&gt; p(newDog, 2);NamedObject&lt;int&gt; s(oldDog, 36);p = s;  // 会发生什么？\n\n解析：\n赋值前：p.nameValue 和 s.nameValue 分别指向不同的 string 对象。\n是否能让 p.nameValue 指向 s.nameValue？\n不行，因为 C++ 不允许让 reference 改指向不同的对象。\n\n\n\n编译器的应对方案：\n如果 class 包含 reference 成员，想要支持赋值操作，必须自己定义 copy assignment 操作符。\n类中如果包含 const 成员，也一样。\n如果某个基类将 copy assignment 操作符声明为 private，编译器也不会为派生类自动生成 copy assignment 操作符。\n\n\n💡 总结了解编译器在背后默默生成的函数有助于我们编写更稳定、可控的 C++ 类。尤其当类中包含 reference、const 或继承关系时，更要注意手动定义复制相关操作。\n\n","categories":["C++基础","effective c++"],"tags":["Effective C++"]},{"title":"条款06：绝不在构造和析构过程中调用虚函数","url":"/2025/04/28/effective_c++/06%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0/","content":"1️⃣ 案例引入\n假设你有个class继承体系，用来塑模股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志（audit log）中也需要创建一笔适当记录。  class Transaction &#123;     //所有交易的 base classpublic:    Transaction();    virtual void logTransaction() const = 0;    //做出一份因类型不同而不同                                                //的日志记录(log entry)&#125;;Transaction::Transaction()     // base class构造函数之实现&#123;    ···    logTransaction();          // 最后动作是志记这笔交易&#125;;class BuyTransaction: public Transaction    //derived class&#123;public:    virtual void logTransaction() const;    //志记（log）此型交易&#125;;class SellTransaction: public Transaction    //derived class&#123;                  public:    virtual void logTransaction() const;     //志记(1og)此型交易&#125;;\n现在，当以下这行被执行，会发生什么事 ?  BuyTransaction b;\n🥵执行过程\nBuyTransaction构造函数被调用\n首先Transaction构造函数一定会更早被调用———derived class对象内的base class成分会在derived class。自身成分被构造之前先构造妥当。\nTransaction构造函数的最后一行调用virtual函数logTransaction，这正是引发惊奇的起点。\n这时候被调用的logTransaction是Transaction内的版本，不是BuyTransaction内的版本———即使目前即将建立的对象类型是BuyTransaction。是的，baseclass构造期间virtual函数绝不会下降到derived classes阶层。取而代之的是，对象的作为就像隶属base类型一样。\n非正式的说法或许比较传神：在base class构造期间，virtual函数不是virtual函数。这一似乎反直觉的行为有个好理由。由于base class构造函数的执行更早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。如果此期间调用的virtual函数下降至derived classes阶层，要知道derived class的函数几乎必然取用local成员变量，而那些成员变量尚未初始化。\n\n\n\n\n🤓根本原因\n在derived class对象的base class构造期间，对象的类型是base class而不是derived class。\n不只virtual函数会被编译器解析至base class，若使用运行期类型信息（例如dynamic_cast和typeid），也会把对象视为base class类型。\n\n\n\n2️⃣ 同理析构函数\n原理\nderived class析构函数开始执行，对象内的derived class成员变量便呈现未定义值，所以C++视它们仿佛不再存在。\n进入base class析构函数后对象就成为一个base class对象，而C++的任何部分包括virtual函数、dynamic_casts等等也就那么看待它。\n\n\n\n","categories":["C++基础","effective c++"],"tags":["Effective C++"]},{"title":"条款07：为多态基类声明成虚析构函数","url":"/2025/04/27/effective_c++/07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%E6%88%90%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/","content":"1️⃣ 问题的引入\n有许多种做法可以记录时间，因此，设计一个TimeKeeper base class和一些derived classes作为不同的计时方法：  class TimeKeeper&#123;public:TimeKeeper () ;~TimeKeeper () :...&#125;;class AtomicClock: public TimeKeeper &#123; ... &#125;;    //原子钟class WaterClock: public TimeKeeper &#123; ... &#125;;    //水钟class WristWatch: public TimeKeeper &#123; ... &#125;;    //腕表\n许多客户只想在程序中使用时间，不想操心时间如何计算等细节，这应该怎么办呢 ？\n使用factory函数\n返回指针指向一个计时对象。Factory函数会 ”返回一个base class指针，指向新生成之derived class对象” ：  TimeKeeper* getTimeKeeper();    //返回一个指针，指向一个                                //TimeKeeper派生类的动态分配对象  \n\n\n\n\n\n2️⃣ 这种方式的缺点\n根本问题\n问题出在getTimeKeeper返回的指针指向一个derived class对象（例如AtomicClock），而那个对象却经由一个base class指针（例如一个TimeKeeper*指针）被删除，而目前的base class（TimeKeeper）有个non-virtual析构函数。\n\n\n引发的灾难\n当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未有定义 :\n实际执行时通常发生的是对象的derived成分没被销毁。如果getTimeKeeper返回指针指向一个AtomicClock对象，其内的AtomicClock成分（也就是声明于AtomicClock class内的成员变量）很可能没被销毁，而AtomicClock的析构函数也未能执行起来。然而其base class成分（也就是TimeKeeper这一部分）通常会被销毁，于是造成一个诡异的“局部销毁”对象。\n\n\n\n\n\n3️⃣ 解决方法\n给base class一个virtual析构函数。\n此后删除derived class对象就会销毁整个对象，包括所有derived class成分  class TimeKeeper&#123;public:TimeKeeper();virtual ~TimeKeeper () :&#125;;TimeKeeper* ptk = getTimeKeeper ();delete ptk;     //现在，行为正确。\n\n4️⃣ 析构函数声明为虚函数的时机\n定义\n如果class不含virtual函数，通常表示它并不意图被用做一个base class。\n当class不企图被当作base class，令其析构函数为virtual往往是个馊主意。\n\n\n案例引入  class Point &#123;public:    Point(int xCoord, int yCoord) ;    ~Point () ;private:    int x, y;&#125;;   \n  如果int占用 32 bits，那么Point对象可塞入一个64-bit 缓存器中。然而当Point的析构函数是virtual，形势起了变化。\n🤓虚函数原理\n欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数该被调用。\n这份信息通常是由一个所谓vptr（virtual table pointer）指针指出。\nvptr指向一个由函数指针构成的数组，称为vtbl(virtual table)；每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl——编译器在其中寻找适当的函数指针。\n\n\n🥵额外的开销\n如果Point class内含virtual函数，其对象的体积会增加：\n在 32-bit 计算机体系结构中将占用64bits（存放两个ints）至96 bits（两个ints加上vptr）；\n在 64-bit 计算机体系结构中可能占用64128 bits，因为指针在这样的计算机结构中占 64bits 。因此，为Point添加一个vptr会增加其对象大小达 50%100% !\n\n\n\n\n\n","categories":["C++基础","effective c++"],"tags":["Effective C++"]},{"title":"条款1：Pointer 和 Reference","url":"/2025/04/01/more_effective_c++/Pointer%20%E5%92%8C%20Reference%20/","content":"1️⃣语言层面共同点\n都是用来参考其他对象。\n\n不同点\nreference必须绑定到某个对象，不产生所谓的空引用null reference，也就是说 reference 在定义时必须要有初值；但是 pointer 可以指向一个对象，也可以不指向任何对象，在定义时可以没有初值。\n\nreference比pointer 更富有效率。因reference在使用前不需要测试有效性，但是pointer 在使用前需要检验指针是否为空。\n\npointer 可以被重新赋值，指向另外一个对象；但是reference总是代表最初获得的对象。\nstring s1(&quot;zhang san&quot;);string s2(&quot;li si&quot;);string&amp; refer = s1;\t\t\t// refer 绑定 s1string* pointer = &amp;s1;\t\t// pointer 指向 s2// 现在进行修改refer = s2;\t\t\t\t\t// refer 仍然绑定 s1,只不过对 refer 的操作实质是                            // 对 refer 绑定的对象进行的操作。                            // 现在 s1 的值为 li si。ps = &amp;s2;\t\t\t\t\t// ps 获得 s2 的地址，指向 s1 ，s1 不会发生变化\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款03：不以多态的性质处理数组","url":"/2025/04/01/more_effective_c++/%E4%B8%8D%E4%BB%A5%E5%A4%9A%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84/","content":"1️⃣ 继承\n继承的最重要性质就是：可以通过“指向base class objects”的 pointers 或 references，来操作 derived class objects。如此的pointers和 references，我们说其行为是多态的。\n\n2️⃣ 问题\nC++允许你通过base class的 pointers和 references来操作“derived class objects“所形成的数组。\n\n3️⃣ 例子class BST &#123; ... &#125;;class BalanceBST : BST &#123; ... &#125;;\n\nvoid printBSTArray(ostream&amp; s, const BST array[], int numElements)&#123;    for (int i = O; i &lt; numElements; ++i) &#123;        s &lt;&lt; array[i];\t// 假设 BST objects 有一个 operator&lt;&lt; 可用。    &#125;&#125;\n\n🔹 当给这个函数传递一个由 BST 对象组成的数组，代码不会产生问题。BST BSTArray[10];...printBSTArray(cout , BSTArray, 10);\n\n🔸 当给这个函数传递一个由 BalanceBST 对象组成的数组，编译器不会发生报错，但是代码并不是我们想象的那样。BalnaceBST bBSTArray[10];...printBSTArray(cout, bBSTArray, 10);\n\n4️⃣ 解析\narray[i] 等价于*(array+i)。array是个指针，指向数组起始处。\narray所指内存和array+i所指内存两者相距多远？答案是i*sizeof(数组中的对象)。因为array[0]和array[i]之间有i个对象。\n为了让编译器所产生的代码能够正确走访整个数组，编译器必须决定数组中的对象大小。由于参数array被声明成“类型为BST”的数组吗？所以数组中的每个元素必然都是BST对象，所以array和array+i之间的距离一定是i*sizeof(BST)。\n但如果交给printBSTArray函数一个由BalancedBST对象组成的数组，编译器就会被误导。这种情况下它仍假设数组中每一元素的大小是BST的大小，但其实每一元素的大小是BalancedBST的大小。由于     derived classes通常比base classes大，因此，我们可以合理地预期一个BalancedBSTobject比一个BSTobject大。如果是这样，编译器为printBSTArray函数所产生的指针算术表达式，对于       BalancedBST objects所组成的数组而言就是错误的。\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款24：了解 virtual function、multiple inheritance、virtual base class、runtime type identification 的成本","url":"/2025/04/05/more_effective_c++/%E4%BA%86%E8%A7%A3%20virtual%20function%E3%80%81multiple%20inheritance%E3%80%81virtual%20base%20class%E3%80%81runtime%20type%20identification%20%E7%9A%84%E6%88%90%E6%9C%AC/","content":"1️⃣ 问题的引入\n当一个虚函数被调用时，执行的代码必须对应于调用者（对象）的动态类型。\n对象的pointer或reference，其类型是无形的，那么编译器是如何有效率的实现这样的行为呢？\n编译器采用的是 virtual table 和 virtual table pointer。\n\n2️⃣ 虚表（virtual table）\n定义\n\nvtbl通常是一个由“函数指针”架构而成的数组。\n程序中的每一个class凡声明（或继承）虚函数者，都有自己的一个vtbl，而其中的条目就是该    class的各个虚函数实现体的指针。\n\n  class C1&#123;public:    C1();    virtual ~C1() ;    virtual void f1() ;    virtual int f2(char c) const;    virtual void f3(const string&amp; s);    void f4 () const;    ...&#125;;\n\n\nC1虚表示意图\n  \n\n注意\n\n非虚函数f4不在表格之中，C1 constructor也一样。\n它们主要位于虚拟内存中的“代码段”。\n\n\n\n  class C2: public C1 &#123;public:    C2();\t\t\t\t\t\t//非虚函数。    virtual ~C2 () ;\t\t\t//重新定义的虚函数。    virtual void f1(); \t\t\t//重新定义的虚函数。    virtual void f5(char *str); //新的虚函数。&#125;;\n\n\nC2 虚表示意图\n  \n\n注意\n\nC2的vtbl内的条目将会指向对应于C2对象类型的各个适当函数，以及未被C2重新定义的  C1的虚函数。\n\n\n\n\n虚函数的成本\n\n必须为每一个拥有虚函数的class耗费一个vbtl空间，其大小视虚函数的个数而定。\n必须为每一个拥有虚函数的对象付出“一个额外指针”的代价。\n放弃了inline。\ninline意味“在编译期，将调用端的调用动作被调用函数的函数本体取代”。\nvirtual则意味着“等待，直到运行时期才知道哪个函数被调用”。\n当编译器面对某个调用动作，却无法知道哪个函数该被调用时，就可以了解为什么它们没有能力将该函数调用加以inlining了。\n\n\n\n\n\n3️⃣ 虚表指针（virtual table pointer ）\n定义\n\n凡声明有虚函数的class，其对象都含有一个隐藏的&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;data member&lt;/font&gt;，用来指向该class的vtbl。这个隐藏的data member——所谓的&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;vptr&lt;/font&gt;——被编译器加入到对象中只有编译器才知道的位置。\n\n拥有虚函数的对象的内存布局：\n  \n\n\n\t\n\n对象、虚表指针，虚表之间的关系\n  \n\n案例引入\n  void makeACall(C1* pC1)&#123;    pC1-&gt;f1();&#125;\n\n\n多态\n通过指针pC1调用虚函数f1。无法知道哪一个f1函数(C1::f1或C2::f1)会被调用，因为pC1可能指向一个C1对象，也可能指向一个C2对象。\n\n\n不论pC1到底指向谁。编译器必须产生代码，完成以下动作：\n根据对象的vptr找出其vtbl。成本只有一个偏移调整（offset adjustment），以便获得 vptr。以及一个指针间接动作，以便获得vtbl。\n\n找出被调用函数在vtbl内的对应指针。成本只是一个偏移(offset)以求进入vtbl数组。\n\n调用所得指针所指向的函数。\n  (*pC1-&gt;vptr[i])(pC1)  // pC1 被传给该函数用来作为 &quot;this&quot; 指针所用\n\n\n\n\n\n4️⃣ 多重继承\n定义\n一个对象内会有多个vptr，每个base class各对应一个。\n\n\n\n5️⃣ 虚拟基类（virtual base class）\n产生原因\n\n在non-virtual base class的情况下，如果derived class在其base class有多条继承路径，则此base class的data members会在每一个derived class object体内复制滋生，每一个副本对应“derived class和base class之间的一条继承路线”。如此的复制现象几乎不会是程序员所想要的。\n让base classes成为virtual，可以消除这样的复制现象。\n\n\n菱形继承\n  class A &#123; ... &#125;;class B: virtual public A &#123; ... &#125;;class C: virtual public A &#123; ... &#125;;class D: public B, public C &#123; ... &#125;;\n\n\n示例图\n\n  \n\nD 对象的内存布局：\n          \n\n\n\n\n6️⃣ runtime type identification\n定义\n\nRTTI让我们在运行期获得object和class的相关信息，所以一定需要有地方来存放相关信息。\n这些信息被存放在类型为type_info的对象中\nvtbl数组之中，索引为 0 的条目内含一个指针，指向“该vtbl所对应的class”的相应的\t\ttype_info对象\n\n\n案例解析\n\nclass C1 的vbtl如下：\n\n  \n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款19：了解“临时对象”的来源","url":"/2025/04/04/more_effective_c++/%E4%BA%86%E8%A7%A3%E2%80%9C%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%9A%84%E6%9D%A5%E6%BA%90/","content":"1️⃣ 什么是临时对象？\n局部变量\n\n在函数作用域定义的temp并非“临时对象”，而是“局部对象”。\n\n template&lt; class T&gt;void swap(T&amp; object1, T&amp; object2)&#123;    T temp = object1;    object1 = object2;    object2 = temp;&#125;\n\n临时对象\n\n“临时对象”是不可见的——不会在你的源代码中出现。\n只要产生一个non-heap object而没有为它命名，便诞生了一个“临时对象”。\n\n\n\n2️⃣ 临时对象产生于什么情况？\n发生隐式类型转换，以求函数调用能够成功。\n当函数返回对象的时候。\n\n3️⃣ 进一步理解“为了让函数调用成功”而产生的临时对象\n产生时机\n\n传递某对象给一个函数，而其类型与它即将绑定上去的参数类型不同。\n\n\n代码解析\n  //返回 ch 在str中的出现个数。size_t countChar(const string&amp; str, char ch);char buffer[MAX_STRING_LEN];char c;//读入一个 char 和一个 string，利用 setw 避免//在读入string时产生缓冲区满溢的情况。cin &gt;&gt; c &gt;&gt; setw (MAX_STRING_LEN) &gt;&gt; buffer;cout &lt;&lt;&quot;There are &quot; &lt;&lt; countChar (buffer, c)    &lt;&lt;&quot; occurrences of the character &quot; &lt;&lt; c    &lt;&lt;&quot; in&quot; &lt;&lt; buffer &lt;&lt; endl;\n\n\n自变量是个char数组，但是相应的函数参数类型却是const string&amp;。\n当“类型不吻合”的状态消除，此函数调用才会成功。\n编译器乐意消除此状态，做法是产生一个类型为string的临时对象。\n该对象的初始化方式是：以buffer作为自变量，调用string constructor。\n于是countChar的str参数会被绑定于此string临时对象上。\n当countChar返回，此临时对象会被自动销毁。\n\n\n转换发生条件\n\n当对象以by value（传值）方式传递\n当对象被传递给一个reference-to-const参数时，这些转换才会发生。\n当对象被传递给一个reference-to-non-const参数，并不会发生此类转换。\n\n\n\n当函数返回一个对象的时候\n案例引入\n  const Number operator+(const Number&amp; lhs,                    const Number&amp; rhs); \n\n解析\n\n此函数的返回值是个临时对象，因为它没有名称：它就是函数的返回值。\n因此，每当调用 operator+，便需要为此对象付出构造和析构成本。\n\n\n解决措施\n\n返回值优化（return value optimization）\n\n\n\n4️⃣ 返回值优化\n案例引入\n  class Rational &#123;public:    Rational(int numerator = 0, int denominator = 1);    ...    int numerator() const;    int denominator() const;    const Rational operator*(const Rational&amp; lhs,                            const Rational&amp; rhs);&#125;;\n\n问题\n\n它返回两个任意数的乘积，operator*如何能够在不产生新对象的情况下放置该乘积呢？\n答案是不可能，所以它必须产生一个新对象并将它返回。\n\n\n\n\n是否可以找出消除“by value 返回方式”的神奇方法？\n\n返回指针？\n  const Rational* operator*(const Rational&amp; lhs,const Rational&amp; rhs);Rational a = 10;Rational b(1, 2) ;Rational c = * (a * b) ;\n\n缺点\n会发生内存泄露\n\n\n\n\n返回引用？\n  const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs);Rational a = 10;Rational b(1, 2);Rational c = a * b;const Rational&amp; operator*(const Rational&amp; lhs,                        const Rational&amp; rhs)&#123;    Rational result(lhs.numerator() * rhs.numerator(),                    lhs.denominator() * rhs.denominator());    return result;&#125;\n\n\n缺点\n函数返回一个reference，指向一个不再存活的对象。\n明确地说，它返回一个reference，指向局部对象result。但result在operator*返回时自动被销毁了。\n\n\n\n\n\n\n\n5️⃣ 返回值的正确做法const Rational operator*(const Rational&amp; lhs,                         const Rational&amp; rhs)&#123;    return Rational(lhs.numerator() * rhs.numerator(),                    lhs.denominator() * rhs.denominator());&#125;\n\n\n解析\nC++允许编译器将临时对象优化，使它们不存在。\n\n如果这样调用operator*,编译器得以消除“operator*内的临时对象”及“被operator*返回的临时对象”。\n  Rational a = 10;Rational b(1, 2);Rational c = a * b;\n\n编译器可以将return表达式所定义的对象构造于c的内存内。\n\n如果这么做，调用operator*时的临时对象总成本为 0，也就是说没有任何临时对象需要被产生出来。\n\n取而代之的是，你只需付出一个constructor（用以产生c）的代价。\n\n\n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款12：了解“抛出一个 exception”与“传递一个参数”或者“调用一个虚函数”之间的差异","url":"/2025/04/03/more_effective_c++/%E4%BA%86%E8%A7%A3%E2%80%9C%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%20exception%E2%80%9D%E4%B8%8E%E2%80%9C%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E2%80%9D%E6%88%96%E8%80%85%E2%80%9C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E2%80%9D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/","content":"1️⃣ 函数参数和catch语句的声明方法class Widget &#123;...&#125;;\t\t\t\t\t //某个class，细节不重要。\n\nvoid f1 (Widget w) ;\t\t\t\t// 所有这些函数需要的参数void f2 (Widget&amp; w) ;\t\t\t\t// 分别是Widget,Widget&amp;void f3 (const Widget&amp; w);\t\t\t// 或 Widget*类型。void f4 (Widget *pw) ;void f5(const Widget *pw);catch (Widget w) ...\t\t\t\t// 所有这些catch子句catch (Widget&amp; w)...\t\t\t\t// 用来捕捉类型为catch (const Widget&amp; w)...\t\t\t// Widget, Widget&amp;或catch (Widget *pw) ...\t\t\t\t// Widget* 的 exceptions。catch (const Widget *pw)...\n\n2️⃣ 相同点\n函数参数和exceptions的传递方式都有三种：by value，by reference，by pointer。\n\n3️⃣ 不同点\n对程序的控制权\n\n当调用函数时，控制权最终会回到调用端。\n当抛出一个exception，控制权不会回到调用端。\n\n\n不论被捕捉的exception是以by value，还是by reference 方式传递，都会发生copy行为。\n //此函数从一个stream中读取一个widget。istream operator&gt;&gt;(istream&amp; s, Widget&amp; w);void passAndThrowWidget ()&#123;    Widget localwidget;    cin &gt;&gt; localWidget;\t\t\t\t//将localwidget 传给operator&gt;&gt;。    throw localWidget;\t\t\t\t//将localwidget抛出成为一个exception。&#125;\n\n\n当localWidget被交到operator&gt;&gt;函数手中，并没有发生copy行为，而是operator&gt;&gt;内的   reference w被绑定于localWidget身上。此时，对w做的事情，其实是施加于localWidget身上的。\n不论被捕捉的exception是以by value或by reference方式传递，都会发生localWidget的复制行为，而交到&lt;font style=&quot;background-color:#FCE75A;&quot;&gt;catch&lt;/font&gt;子句手上的正是那个副本。一旦控制权离开passAndThrowWidget，localWidget便离开了作用域，于是localWidget destructor会被调用。\n\n\n可以将一个临时对象传递给exception。\n\ncatch 语句总是按照出现顺序做匹配尝试\n\n缺点\n\n当try语句块中分别有针对base class而设计和针对derived class而设计的catch子句，一个derived class exception仍有可能被“针对base class而设计的catch子句”处理掉。\n  try &#123;    ...&#125;    catch (logic_error&amp; ex) &#123;\t\t\t\t//此语句块将捕捉所有的    ...\t\t\t\t\t\t\t\t\t// logic_error exceptions,&#125;\t\t\t\t\t\t\t\t\t\t//甚至包括其 derivedtypes。    catch (invalid_argument&amp; ex) &#123;\t\t\t//此语句块绝不会执行起来，    ...\t\t\t\t\t\t\t\t\t// 因为所有的invalid_argument&#125;\t\t\t\t\t\t\t\t\t\t//exceptions都会被上述子句捕捉。\n\n\n与虚函数的差异\n\n虚函数执行的是“best fit”(最佳吻合)策略\nexception执行的是”first fit“(最先吻合)策略\n\n\n\n\n\n4️⃣ 进一步理解\nexception objects必定会造成复制行为，这导致其效率不高。\n\n当对象被复制当做一个exception，复制行为是由对象的copy constructor执行的。这个                  copy constructor相应于该对象的“静态类型”而非“动态类型”。\n  class Widget &#123; ... &#125;;class Specialwidget : public Widget ( ... &#125;;void passAndThrowWidget ()&#123;    Specialwidget localSpecialwidget;    ...    Widget&amp; rw = localSpecialwidget; // rw 代表一个 Specialwidget。    throw rw;\t\t//抛出一个类型为 Widget 的 exception。&#125;\n\n\n这里抛出的是一个widget exception——虽然rw实际代表的是一个Special widget。\n这是因为rw的静态类型是widget而非Specialwidget。\nrw虽然代表一个SpecialWidget，编译器却不关心这个事实，它们关心的是rw的静态类型。\n\n\n\n5️⃣ 如何在 catch 语句块内再次传播 exceptioncatch (Widget&amp; w)\t\t\t\t// 捕捉 widget exceptions。&#123;    ...\t\t\t\t\t\t\t// 处理 exception。    throw;\t\t\t\t\t\t//重新抛出此exception,&#125;\t\t\t\t\t\t\t\t//使它能继续传播。 catch (Widget&amp; w)\t\t\t\t// 捕捉 widget exceptions。&#123;    ...\t\t\t\t\t\t\t// 处理exception。    throw w;\t\t\t\t\t// 传播被捕捉的exception&#125;\t\t\t\t\t\t\t\t// 的一个副本。\n\n\n这两个catch语句块之间唯一的差异就是，前者重新抛出当前的exception，后者抛出的是当前            exception的副本。这两种做法的区别是什么？\n第一语句块，重新抛出当前的exception，不会根据其类型之前的类型是什么。\n第二语句块，抛出一个新的exception，其类型总是widget，因为那是w的静态类型。\n\n\n那种做法更好？\n一般而言，你必须使用以下语句：throw，才能重新抛出当前的exception。\n此外，它也比较有效率，因为不需要产生新的exception object。\n\n\n\n6️⃣ 三种 catch 子句catch (Widget w) ...\t\t\t\t// 以 by value 的方式捕捉。catch (Widget&amp; w) ...\t\t\t\t// 以 by reference 的方式捕捉。catch (const Widget&amp; w) ...\t\t\t// 以 by reference-to-const 的方式捕捉。\n\n\n“参数传递”和“exception 传播”的另一个区别\n一个被抛出的对象，一定是个临时对象。\n在函数调用中，将一个临时对象传递给一个non-const reference参数是不允许的；但是对             exception是合法的。\n\n\n\n7️⃣ 回到“复制 exception objects”主题\n以&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;by value&lt;/font&gt;方式捕捉&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;exception&lt;/font&gt;，便是对被传递的对象做一个副本。\n\ncatch (Widget w) ...\t\t\t// 以 by value 方式捕捉\n\n- 预期付出“被抛出物”的“两个副本”的构造代价。\n    * 其中一个构造动作用于“任何`exceptions`都会产生的临时对象”身上。\n    * 另一个构造动作用于“将临时对象复制到`catch`语句中的参数`w`”。\n\n\n以by reference方式捕捉exception，便是对被传递的对象做一个引用。\n  catch (Widget&amp; w) ...\t\t\t// 以 by reference 方式捕捉\n\n\n预期付出“被抛出物”的“一个副本”的构造代价。\n这里的副本便是指临时对象。由于以by reference方式传递函数参数时并不会发生复制行为，所以“抛出exception”和“传递函数参数”相比，前者会多构造一个“被抛出物”的副本（并于稍后析构）。\n\n\n\n\n\n8️⃣ exception 与 catch 语句的类型吻合\n一般不会发生类型转换\n  void f(int value)&#123;    try &#123;        if (someFunction()) &#123;\t\t\t// 如果 someFunction()返回true,            throw value;\t\t\t\t//就抛出一个int。        &#125;    &#125;    catch (double d) &#123;\t\t\t\t\t// 在这里处理类型为double的exceptions。        ...    &#125;    ...&#125;\n\n\ntry 语句块抛出的int exception绝不会被“用来捕捉double exception”的catch子句捕捉。\n后者只能捕捉类型确确实实为double的exceptions，其间不会有类型转换的行为发生。\n所以，如果int exception被捕捉，它一定是被某些其他（也许是外围的）catch子句捕捉的（它们的捕捉类型一定是int或int&amp;，或许再加上const或volatile之类的限定词）。\n\n\n仅有两种转换可以发生\n\n继承结构中的类转换（inheritance-based conversions)\n一个针对base class exceptions编写的catch子句，可以处理类型为derived class的  exceptions。\n第二个允许发生的转换是从一个“有型指针”转为“无型指针”，所以一个针对const void*指针而设计的catch子句，可捕捉任何指针类型的exception：catch（const void*）。\n\n\n\n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款8：了解各种不同意义的 new 和 delete","url":"/2025/04/03/more_effective_c++/%E4%BA%86%E8%A7%A3%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%84%8F%E4%B9%89%E7%9A%84%20new%20%E5%92%8C%20delete/","content":"1️⃣ 问题的引入\n如何理解new operator 和 opertor new 之间的差异 ？\n什么是 placement new，它的作用是什么？\n\n2️⃣ 案例解析string* ps = new string(&quot;Memory Management&quot;);\n\n\n这里使用的new是所谓的new operator。这个操作符是由语言内建的，不能被改变意义。\n它的动作以下两方面：\n第一，它分配足够的内存，用来放置某类型的对象。\n第二，它调用一个constructor，为刚才分配的内存中的那个对象设定初值。\n\n\n我们能够改变的是用来容纳对象的那块内存的分配行为。\nnewo perator调用某个函数，执行必要的内存分配，我们可以重写那个函数，改变其行为。\n这个函数的名称叫做operator new。\n\n\n\n3️⃣ 进一步理解\n函数operator new 的定义式：\n\nvoid* operator new(size_t size);\n\n- 返回值和参数解析\n    * 返回值类型为 `void*`，返回的指针，指向一块原始的、未设初值的内存\n    * `size_t` 表示需要分配多少内存。\n    * `operator` 可以被重载，加上额外的参数，但是第一参数必须是`size_t`。\n- 作用\n    * `operator new`和`malloc`一样。它唯一任务就是分配内存。它不知道什么是`constructr`，  `operator new`只负责内存分配。\n\n\nnew operator的流程\n\nvoid *memory =\t\t\t\t\t\t\t\t//取得原始内存（rawmemory)。    operator new(sizeof(string));\t\t\t//用来放置一个string对象。call string::string（&quot;MemoryManagement&quot;) \t// 将内存中的对象初始化。on *memory;string *ps =\t\t\t\t\t\t\t\t//让ps指向新完成的对象。    static_cast&lt;string*&gt;(memory);\n\n4️⃣ Placement new\n应用场景：你已拥有一些分配好的原始内存，只需要在上面构建对象。\n\nclass Widget &#123;public:    Widget(int widgetSize);...&#125;；Widget * constructWidgetInBuffer(void *buffer, int widgetSize)&#123;    return new (buffer) Widget (widgetSize);&#125;\n\n\n解析\n函数返回指针，指向一个Widgetobject，它被构造于传递给此函数的一块内存缓冲区。\nnew (buffer) Widget (widgetSize);\n指定一个额外自变量(buffer)作为new operator隐式调用operator new时所用。\n被调用的operator new除了接受一定得有的size_t自变量之外，还接受了一个void*参数，指向一块内存，准备用来接受构造好的对象。\n\n\n\n\n作用\noperator new的目的是要为对象找到一块内存，然后返回一个指针指向它。\n在placement new的情况下，调用者已经知道指向内存的指针了，因为调用者知道对象应该放在哪里。因此placement new唯一需要做的就是将它获得的指针再返回。\n\n\n\n5️⃣ 三类new的使用场景\n如果你只是打算分配内存，请调用operator new，那就没有任何constructor会被调用。\n如果你打算在heap objects产生时自己决定内存分配方式，请写一个自己的operator new，并使用   new operator，它将会自动调用你所写的operator new。\n如果你打算在已分配（并拥有指针）的内存中构造对象，请使用placement new。\n\n6️⃣ 删除（Deletion）与内存释放（Deallocation）\n问题的引入\n\n为了避免resourceleaks（资源泄漏），每一个动态分配行为都必须匹配一个相应但相反的释放动作\noperator delete对于内建的delete operator，等价operator new对于new operator一样\n\n\n案例引入\n  string* ps;...delete ps;\n\ndelete 的执行流程\n\n先调用ps-&gt;~string()，先调用对象的析构函数。\n再调用operator delete(ps),再释放对象所占用的内存。\n\n\n进一步理解\n\n如果使用placement new，在某内存块中产生对象，就避免对那块内存使用delete operator。\n因为delete operator会调用operator delete来释放内存，但是该内存内含的对象最初并非是由operator new分配得来的。\n毕竟placement new只是返回它所接收的指针而已，谁知道那个指针从哪里来呢？所以为了抵消该对象的constructor的影响，你应该直接调用该对象的destructor。\n\n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款6：了解各种不同意义的 new 和 delete","url":"/2025/04/02/more_effective_c++/%E5%8C%BA%E5%88%86%20++%20%E5%92%8C%20--%20%20%E7%9A%84%E5%89%8D%E7%BD%AE(prefix)%E5%92%8C%E5%90%8E%E7%BD%AE(postfix)%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"1️⃣问题的引入\n重载函数是以参数类型来区分彼此，然而不论 ++或 – 操作符的前置或后置式，都没有参数。\n\n为了填平语言上的漏洞，只好让后置式有一个int自变量，并且在它被调用时，编译器默默为该int指定一个0值。\n  class UPInt &#123;\t\t\t\t\t \t\t// &quot;unlimited precision int&quot;public:    UPInt&amp; operator++();\t\t\t\t//前置式(prefix)++。    const UPInt operator++(int);\t\t//后置式(postfix)++。    UPInt&amp; operator--();\t\t\t\t// 前置式(prefix)-—。    const UPInt operator--(int);\t\t//后置式(postfix)--。    UPInt&amp; operator+=(int);\t\t\t\t//+=操作符，结合UPInts和intS。...&#125;;UPInt i;++i;\t\t\t\t// 调用i.operator++();i++;\t\t\t\t// 调用i.operator++(0);--i;\t\t\t\t//调用i.operator--();i--\t\t\t\t\t// 调用i.operator--(0);\n\n2️⃣前置式和后置式的区别\n前置式返回一个引用reference，后置式放回一个 const 对象。\n\n++ 操作符的前置式意义increment and fetch(累加然后取出)，后置式意义fetch and incremet(取出然后累加）。\n  //前置式:累加然后取出（incrementandfetch)。UPInt&amp; UPInt::operator++()&#123;    *this += 1;\t\t//累加（increment）。    return *this;\t// 取出（fetch)。&#125;//后置式:取出然后累加（fetchandincrement)。const UPInt UPInt::operator++(int)&#123;UPInt oldValue = *this;\t\t//取出（fetch)。    ++(*this);\t\t\t\t\t//累加（increment)。    return oldValue;\t\t\t//返回先前被取出的值。 &#125;\n\n后置式会产生临时对象，作为返回值，效率低于前置式。\n\n\n3️⃣进一步理解\n为什么后置式++操作符必须返回一个对象（代表旧值），原因很清楚。但为什么是个const对象呢？\n UPInt i;i++++;\t\t\t//实施“后置式increment操作符”两次。\n\n\noperator++ 的第二个调用动作施行于第一个调用动作的返回对象身上。\n第二个operator++所改变的对象是第一个operator++返回的对象，而不是原对象。因此即使下式合法：i++++; i也只被累加一次而已。\n\n\n如何确保前置式和后置式行为一致？\n 原则：后置式++和--操作符的实现应以其前置式兄弟为基础。如此一来你就只需维护前置式版本，因为后置式版本会自动调整为一致的行为。\n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款25：将 constructor和 non-member function 虚化","url":"/2025/04/06/more_effective_c++/%E5%B0%86%20constructor%E5%92%8C%20non-member%20function%20%E8%99%9A%E5%8C%96/","content":"1️⃣ Virtual constructor\nvirtual constructor听起来很荒谬，但是它们很有用。\n\n2️⃣ 案例引入class NLComponent &#123;\t\t\t\t//\t抽象基类，用于时事消息public:\t\t\t\t\t\t\t//\t的组件(components)，    ...\t\t\t\t\t\t\t//\t其中内含至少一个纯虚函数。&#125;;class TextBlock: public NLComponent &#123;public:    ...\t\t\t\t\t\t\t// 没有内含任何纯虚函数。&#125;;class Graphic: public NLComponent &#123;public:    ...\t\t\t\t\t\t\t// 没有内含任何纯虚函数。&#125;;class NewsLetter &#123;\t\t\t\t//一份时事通信是由一系列的public:\t\t\t\t\t\t\t// NLComponent 对象构成的。    ...private:    list&lt;NLComponent*&gt; components;&#125;;\n\n\nclasses 彼此之间的关系\n  \n\n目的\n\nNewsLetter对象尚未开始运作的时候，可能存储于磁盘中。\n为了能根据磁盘上的数据产出一份Newsletter，如果我们让NewsLetter拥有constructor并用istream作为自变量，会很方便。\n这个constructor将从stream读取数据以便产生必要的list&lt;NLComponent&gt;：\n\n\n\nclass NewsLetter &#123;public:    NewsLetter(istream&amp; str);    ...&#125;;// 此 constructor 的伪代码(pseudo code)可能看起来像这样：NewsLetter::NewsLetter(istream&amp; str)&#123;    while (str) &#123;        read the next component object from str;                add the object to the list of this        newsletter&#x27;s components;    &#125;&#125;\n\n或者，如果将棘手的东西搬移到另一个名为readcomponent的函数，就变成这样：\nclass NewsLetter &#123;public:    ...private:    //从str读取下一个 NLComponent 的数据，    //产生组件（component），并返回一个指针指向它。    static NLComponent * readComponent(istream&amp; str);    ...&#125;;NewsLetter::NewsLetter(istream&amp; str)&#123;    while (str) &#123;        //将 readComponent 返回的指针加到 componentslist 尾端        components.push_back(readComponent(str));    &#125;&#125;\n\n\n🥵readComponent做了什么事情？\nreadComponent 产生一个崭新对象，或许是个TextBlock，或许是个Graphic，视读入的数据而定。这些都是NLComponent的子类。\n由于readComponent产生新对象，所以行为仿若constructor，但它能够产生不同类型的对象，所以我们称它为一个virtual constructor。\n所谓virtual constructor是某种函数，视其获得的输入，可产生不同类型的对象。\n\n\n\n3️⃣ Virtual copy constructor\n定义\n\nVirtual copy constructor会返回一个指针，指向其调用者（对象）的一个新副本。\n\n\n实现方式\n  class NLComponent&#123;public:    // 声明 virtual copy constructor    virtual NLComponent* clone () const = 0;    ...&#125;;class TextBlock: public NLComponent&#123;public:    virtual TextBlock* clone() const\t\t// virtual copy constructor    &#123;         return new TextBlock(*this);     &#125;    ...&#125;;class Graphic: public NLComponent&#123;public:    virtual Graphic* clone() const\t\t\t// virtual copy constructor    &#123;        return new Graphic(*this);     &#125;    ...&#125;;\n\n\n解析\nclass的virtual copy constructor调用实际的copy constructor。\n“copy”这层意义对这两个函数而言是一样的。\n如果真正的copy constructor执行的是浅复制，virtual copy constructor也一样。\n如果真正的copy constructor执行的是深复制，virtual copy constructor也一样\n如果真正的copy constructor做了某些煞费苦心的动作，如reference counting（引用计数）或copy-on-write（写时复制)，virtualcopyconstructor也一样。\n\n\n\n\n原理\n当derived class重新定义其base class的一个虚函数时，不一定需要声明与原本类型相同的返回类型。\n如果虚函数的返回类型是指针（或&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;reference&lt;/font&gt;）指向一个&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;base class&lt;/font&gt;，则&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;derived class&lt;/font&gt;的函数可以返回一个指针（或&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;reference&lt;/font&gt;)，指向该&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;base class&lt;/font&gt;的一个&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;derived class&lt;/font&gt;。\n\n\n\n\n\n实现_ NewsLetter _的 copy constructorclass NewsLetter &#123;public:    NewsLetter(const NewsLetter&amp; rhs);\t\t\t// copy constructor    ...private:    list&lt;NLComponent*&gt; components;&#125;;/* 保证对象元素的正确性，不会发生类型偏移 */NewsLetter::NewsLetter(const NewsLetter&amp; rhs)&#123;      for (list&lt;NLComponent*&gt;::const_iterator it = rhs.components.begin() ;        it != rhs.components.end();        ++it)     &#123;        components.push_back((*it)-&gt;clone ());    &#125;&#125;\n\n4️⃣ 将 Non-Member Functions 的行为虚化\n就像constructors无法真正被虚化一样，non-member functions也是。\n\n然而就像我们认为应该能够以某个函数构造出不同类型的新对象一样，我们也认为应该可以让non-member functions的行为视其参数的动态类型而不同。\n\n举个例子，假设你希望为TextBlock``和Graphic实现出output操作符，明显的办法就是让output操作符虚化。然而，output操作符(operator&lt;&lt;)获得一个ostream&amp;作为其左端自变量，因此它不可能成为TextBlock或Graphic class的一个member function。\n  class NLComponent &#123;public:    // output operator的非传统声明。    virtual ostream&amp; operator&lt;&lt;(ostream&amp; str) const = 0;    ...&#125;;class TextBlock: public NLComponent &#123;public:    //virtualoutput operator（也是打破传统）。    virtual ostream&amp; operator&lt;&lt;(ostream&amp; str) const;&#125;;class Graphic: public NLComponent &#123;public:    //virtualoutput operator（也是打破传统)。    virtual ostream&amp; operator&lt;&lt;(ostream&amp; str) const;&#125;;TextBlock t;Graphic g;...    t &lt;&lt; cout;\t\t// 通过 virtual operator&lt;&lt;,在 cout 身上                //打印出 t。注意此语法与传统不符。g &lt;&lt; cout;\t\t// 通过virtual operator&lt;&lt; 在 cout 身上                //打印出g。注意此语法与传统不符。\n\n5️⃣ 正确做法\n同时定义operator&lt;&lt; 和print，并令前者调用后者。\n  class NLComponentpublic:    virtual ostream&amp; print(ostream&amp; s) const = 0;&#125;;class TextBlock: public NLComponent &#123;public:    virtual ostream&amp; print(ostream&amp; s) const;    ...&#125;;class Graphic: public NLComponent &#123;public:    virtual ostream&amp; print(ostream&amp; s) const;...&#125;;inlineostream&amp; operator&lt;&lt;(ostream&amp; s, const NLComponent&amp; c)&#123;    return c.print(s);&#125;\n\nnon-memberfunction的虚化十分容易\n\n写一个虚函数做实际工作，再写一个什么都不做的非虚函数，只负责调用虚函数。\n当然啦，为了避免此巧妙安排蒙受函数调用所带来的成本，你可以将非虚函数inline化。\n\n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款11：禁止异常（exceptions）流出 destructor 之外","url":"/2025/04/03/more_effective_c++/%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%EF%BC%88exceptions%EF%BC%89%E6%B5%81%E5%87%BA%20destructor%20%E4%B9%8B%E5%A4%96/","content":"1️⃣ destructor 函数的调用时机\n对象正常状态下被销毁，也就是当它离开了它的作用域（scope）或是被明确地删除。\n当对象被exception处理机制销毁——也就是exception传播过程中的（stack-unwinding）机制。\n\n2️⃣ 理由一\n有个exception正撰写你的destructor。因为如果控制权基于exception的因素离开destructor，而此时正有另一个exception处于作用状态，C++会调用terminate函数。\n  class Session&#123;public:    Session();    ~Session();...private:    static void logCreation(Session* objAddr);    static void logDestruction(Session* objAddr);&#125;;\n\n函数 logCreation 和 logDestruction 分别用来记录对象的构造和析构。\n  Session::~Session()&#123;    logDestruction(this);&#125;\n\n\n如果 logDestruction抛出一个异常 exception，会发生什么事情？\n首先，这个exception并不会被Session::destructor捕捉，所以它会传播到destructor的调用端。\n其次，万一这个destructor本身是因其他某个exception而被调用的，terminate函数便会被自动调用，于是程序会直接走上了黄泉路。\n\n\n\n\n\n3️⃣ 理由二\n如果exception从 destructor 内抛出，而且没有在本地被捕捉到，那么就destructor执行不完全。\n  Session::Session()\t\t\t\t// 为了简化，这个ctor不处理exceptions。&#123;    logCreation(this);    startTransaction(); \t\t// 开始一个数据库事务。&#125;Session::~Session()&#123;    logDestruction(this);    endTransaction();\t\t\t//结束一个数据库事务。&#125;\n\n如果logDestruction抛出一个exception，于Session::Session内创建的那个Transaction绝对不会结束。\n\n或许在本例中，我们可以调换destructor中语句的位置，但是如果endTransaction抛出异常，同样    destructor中不会执行完整。\n\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"条款26：限制某个class所能产生的对象的数量","url":"/2025/04/05/more_effective_c++/%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAclass%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E9%87%8F/","content":"1️⃣ 允许零个或一个对象\n定义\n每当即将产生一个对象，我们确知一件事情：会有一个constructor被调用。\n“阻止某个class产出对象”的最简单方法就是将其 private\n\n\n\n2️⃣ 问题的引入\n假设我想为打印机设计一个class，我希望设下“只能存在一台打印机”的约束。\n\n我们可以将”打印机对象“封装在某个函数内，如此一来每个人都能够取用打印机，但只有唯一一个打印机对象会被产生。\n  class PrintJob;\t\t\t//前置声明class Printer &#123;public:    void submitJob(const PrintJob&amp; job);    void reset ();    void performSelfTest ();    ...    friend Printer&amp; thePrinter();private:    Printer();    Printer(const Printer&amp; rhs);&#125;;Printer&amp; thePrinter ()&#123;    static Printerp; //唯一的一个打印机对象。    return p;&#125;\n\n\n类的设计思想\n第一，Printer class的constructor属性是private，可以压制对象的诞生。\n第二，全局函数thePrinter被声明为此class的一个friend，致使thePrinter不受        private constructors的约束。\n第三，thePrinter内含一个static Printer对象，意思是只有一个Printer对象会被产生出来。\n\n\n\n\n\n3️⃣ 值得探讨的地方第一点\n形成唯一一个Printer对象的，是函数中的static对象而非class中的static对象\n优点一\n“class拥有一个static对象”的意思是：即使从未被用到，它也会被构造（及析构。\n“函数拥有一个static对象”的意思是：此对象在函数第一次被调用时才产生。\n\n\n优点二\nfunction static的初始化时机：在该函数第一次被调用时，并且在该static被定义处。至于一个class static(或是global static) 则不一定在什么时候初始化。\nC++对于“同一编译单元内的statics”的初始化顺序是有提出一些保证的，但对于“不同编译单元内的statics”的初始化顺序没有任何说明。\n\n\n\n\n\n第二点\n函数的”static对象“与inlining的互动。\n为什么不被不将thePrinter申明成inline?\ninline对于non-member functions意味着这个函数有内部连接(internal linkage)。\n函数如果带有内部连接，可能会在程序中被复制，也就是说程序的目标代码（object code）可能会对带有内部连接的函数复制一份以上的代码，而此复制行为也包括函数内的static对象。\n结果呢，如果你有一个&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;inline non-member function&lt;/font&gt;并于其中内含一个&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;local static&lt;/font&gt;对象，你的程序可能会拥有多份该&lt;font style=&quot;background-color:#FBDE28;&quot;&gt;static&lt;/font&gt;对象的副本。\n所以，千万不要产生内含 local static对象的 inline non-member functions。\n\n\n\n\n\n4️⃣ 对象计数\n目的\n\n利用numObjects来追踪记录目前存在多少个Printer对象。这个数值将在constructor中累加，并在destructor中递减。如果外界企图构造太多Printer对象，我们就抛出一个类型为\t\tTooManyObjects的exception\n\n\n案例\n  class Printer &#123;public:    class TooManyObjects ();\t//当外界申请太多对象时，                                // 抛出这种 exceptionclass。    Printer();    ~Printer();    ...private:    static size_t numObjects;    Printer(const Printer&amp;rhs);\t//有着“打印机个数永远为 1”的限制，                                //所以决不允许复制行为。&#125;;size_t Printer::numObjects = 0;Printer::Printer()&#123;    if (numObjects &gt;= 1) &#123;        throw TooManyObject();    &#125;    proceed with normal construction here;    ++numObjects;&#125;Printer::~Printer()&#123;    perform normal destruction here;    --numobjects;&#125;\n\n","categories":["C++基础","More Effective C++"],"tags":["More Effective C++"]},{"title":"协程调度模块","url":"/2025/12/22/sylar/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97/","content":"1️⃣ 什么是协程调度器？协程调度器（Scheduler）本质上是把“要运行的协程&#x2F;任务”分配到“可用的线程”上执行的调度中心。在 Sylar 里它封装的是一种 N-M 调度模型：N 个协程（Fiber &#x2F; 回调函数）复用 M 个线程。调度器内部维护一个线程池和任务队列，外部通过 schedule() 把 Fiber 或 std::function&lt;void()&gt; 投递进来；当队列从空变为非空时，调度器会通过 tickle() 唤醒处于 idle() 的空闲线程&#x2F;空闲协程去取任务执行。这样做的好处是：协程切换发生在用户态、成本低，同时又能利用多线程把不同协程并行跑起来，实现高并发下的高效调度与资源利用。\n2️⃣ 整体框架图\n3️⃣ 代码类图\n4️⃣ 模块解析私有成员变量\nm_name：调度器的名称\nm_mutex：互斥量\nm_threads：线程池\nm_tasks：任务队列\nm_tids：线程池中包含的线程id\nm_threadCount：线程数量\nm_activeCount：活跃线程数量\nm_idleCount：不活跃线程数量\nm_useCaller：判断是否执行Scheduler构造函数的线程\nm_rootFiber：当 m_userCaller &#x3D; true 时，主协程以后的第一个协程\nm_rootThread：当 m_userCaller &#x3D; true 时，调度器所在线程的线程id\nm_stopping：调度器是否正在停止\n\n全局变量\nt_schedule\n类型：static thread_local Scheduler*\n作用：\n每个线程都有一个独立的 t_schedule，指向“这个线程当前正在使用&#x2F;运行的 Scheduler”。\n让 Scheduler::GetThis() 能在任意位置直接拿到本线程的调度器。\n\n\n\n\nt_schedule_fiber\n类型：static thread_local Fiber*\n作用：\n每个线程都有一个独立的 t_schedule_fiber，指向“本线程用于调度的那条主协程（调度协程）”。\n让 Scheduler::GetMainFiber() 能返回本线程的主 Fiber，并且在 run()/idle() 等调度逻辑里实现“从工作协程切回调度协程&#x2F;主协程”的切换。\n\n\n\n\n\n嵌套类（SchedulerTask）class ScheduleTask&#123;public:  friend class Scheduler;  /**    *  @brief 默认构造函数     */  ScheduleTask()  &#123;    threadid =  -1;  &#125;     /**    *  @brief 构造函数     */  ScheduleTask(Fiber::ptr f, int thr)  &#123;    fiber = f;    threadid = thr;  &#125;  ScheduleTask(Fiber::ptr* f, int thr)  &#123;    fiber.swap(*f);    threadid = thr;  &#125;  ScheduleTask(std::function&lt;void()&gt; c, int thr)  &#123;    cb = c;    threadid = thr;  &#125;          void reset()  &#123;    fiber = nullptr;    cb = nullptr;    threadid = -1;  &#125;        private:  Fiber::ptr fiber;  std::function&lt;void()&gt; cb;  int threadid;&#125;;\n\n作用：定义了任务的类型，只接受协程和用于执行的函数\n私有成员变量\nfiber：协程\ncb：函数\nthreadid：协程和函数运行在哪个线程\n\n\n重要函数\n只有构造函数用于创建一个需要调度的任务。\n\n\n\n重要成员函数接下来将根据：Scheduler()[ user_caller 也就是主线程 Main 是否需要下水干活]、start()[线程池如何启动]、schedule()[如何放任务进去]、run()[线程如何消费任务，如何切换协程]、idle()[没任务时干啥]、stop()[怎么结束]\n构造函数  Scheduler::Scheduler(size_t threads, bool use_caller, const std::string&amp; name)&#123;  SYLAR_ASSERT(threads &gt; 0);  m_useCaller = use_caller;  m_name = name;  if (use_caller)         // 这表示打算将当前的线程用作调度线程  &#123;      --threads;          // 将调度线程的数量减一      Fiber::GetThis();   // 创建 caller 线程的主协程      SYLAR_ASSERT(GetThis() == nullptr);          t_schedule = this;  // 将当前线程的调度器上下文表示为自己      /**       * caller 线程的主协程不会被调度协程run进行调度，而且，线程的调度协程停止时，应该返回到caller的主协程       * 在user caller情况下，把caller线程的主协程暂时保存起来，等调度协程结束时，再resume caller协程       */      m_rootFiber.reset(new Fiber(std::bind(&amp;Scheduler::run, this), 0, false));   // 创建主协程后的调度协程      Thread::setName(m_name);               // 设置线程名称      t_schedule_fiber = m_rootFiber.get();  // 保存调度协程      m_rootThread = sylar::GetThreadId();   // 设置线程id      m_tids.push_back(m_rootThread);        // 将当前线程id保存到线程id集合中  &#125;  else  &#123;      m_rootThread = -1;  &#125;  m_threadCount = threads;&#125;\n\n作用\n如果打算将当前的线程用作调度线程，则创建针对当前线程的第一个协程，并通过 t_schedue 表示调度的线程是当前线程。\n之后创建一个子协程当成调度协程，将 run 函数当作协程的入口函数，并设置调度器的名字为当前线程的名字。\n最后将调度协程保存到 t_scheduler_fiber 中，并将当前线程 id 保存到线程池中。\n\n\n\nstart 函数  void Scheduler::start()&#123;    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;start()&quot;;    MutexType::Lock lock(m_mutex);    if (m_stopping)    &#123;        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;Scheduler is stopping&quot;;        return;    &#125;    SYLAR_ASSERT(m_threads.empty());    m_threads.resize(m_threadCount);    for (size_t i = 0; i &lt; m_threads.size(); ++i)    &#123;        m_threads[i].reset(new Thread(std::bind(&amp;Scheduler::run,this), m_name + &quot;_&quot; + std::to_string(i)));        m_tids.push_back(m_threads[i]-&gt;getId());    &#125;&#125;\n\n作用：\n遍历当前的线程池，创建指定数量的线程来执行 run 函数，并将每个线程的 id 保存到线程 id 集合中。\n\n\n\nschedule 函数  template&lt;typename FiberOrcb&gt;void schedule(FiberOrcb ft, size_t threadid = -1)&#123;    bool need_tickle = false;    &#123;        MutexType::Lock lock(m_mutex);        need_tickle = scheduleNoLock(ft, threadid);    &#125;    if (need_tickle)    // 这说明现在任务队列中有任务，需要唤醒idle协程    &#123;        tickle();       // 唤醒idle协程    &#125;&#125;\n  template&lt;typename FiberOrcb&gt;bool scheduleNoLock(FiberOrcb ft, size_t threadid)&#123;    bool need_tickle = m_tasks.empty();    ScheduleTask task(ft, threadid);    if (task.fiber || task.cb)    &#123;        m_tasks.push_back(task);    &#125;     return need_tickle;     &#125;\n\n作用\n根据 Fiber 或者回调函数 cb 创建一个任务 task，放进任务队列中 m_task，并设置 need_tickle 为 true。\n如果 need_tickle 不为 false，这说明现在任务队列中有任务，就需要唤醒 idle 协程。\n\n\n\nrun 函数  void Scheduler::run()&#123;    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;run&quot;;    // 这主要用于hook系统调用    set_hook_enable(true);     // 调度器创建的每个线程都会有个变量t_schedule指向调度器     setThis();      if (sylar::GetThreadId() != m_rootThread)   // 这表示不是当前线程的id不是调度线程的id    &#123;        t_schedule_fiber = sylar::Fiber::GetThis().get();   // 线程创建协程    &#125;    Fiber::ptr idle(new Fiber(std::bind(&amp;Scheduler::idle, this)));  // 创建懒惰携程    Fiber::ptr cb_fiber;    ScheduleTask task;      while (true)    &#123;        task.reset();        bool tickle_me = false;     // 是否tickle其他线程进行任务调度        &#123;            MutexType::Lock lock(m_mutex);            auto it = m_tasks.begin();            while (it != m_tasks.end())            &#123;                /**                *  @brief 情况一：当前任务指定了调度线程，但不是当前线程                */                if (it-&gt;threadid != -1 &amp;&amp; it-&gt;threadid != sylar::GetThreadId())                &#123;                    ++it;                    tickle_me = true;                    continue;                &#125;                // 判断任务至少存在                SYLAR_ASSERT(it-&gt;fiber || it-&gt;cb);                                /**                *  @brief 情况二：当前任务存在，但是正在运行在该线程的协程上                */                if (it-&gt;fiber &amp;&amp; it-&gt;fiber-&gt;getState() == Fiber::RUNNING)                &#123;                    ++it;                    continue;                &#125;                /**                *  @brief 情况三：当前调度线程找到了一个任务，准备开始调度（将其从任务队列中删除，活动线程数量加一）                */                task = *it;                m_tasks.erase(it++);                ++m_activeCount;                break;            &#125;                        // 当前线程如果拿到一个任务后，发现任务队列中还有任务，就tick其他线程            tickle_me |= (it != m_tasks.end());                    &#125;        // 通知其他线程        if (tickle_me)        &#123;            tickle();        &#125;        if (task.fiber)        &#123;            // 使该task对应的协程执行，resume返回时，协程要么执行完了，要么半路yield了，总之这个任务就算完成了，活跃线程数减一            task.fiber-&gt;resume();            --m_activeCount;            task.reset();        &#125;        else if (task.cb)        &#123;            if (cb_fiber)            &#123;                cb_fiber-&gt;reset(task.cb);            &#125;            else            &#123;                cb_fiber.reset(new Fiber(task.cb));            &#125;            task.reset();            cb_fiber-&gt;resume();            --m_activeCount;            cb_fiber.reset();        &#125;        else    // 进入到这个分支，说明没有在任务队列中取到task        &#123;            if (idle-&gt;getState() == Fiber::TERM)            &#123;                // 这说明调度器已被停止                SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;idle fiber term&quot;;                break;            &#125;            ++m_idleCount;            idle-&gt;resume();            --m_idleCount;        &#125;    &#125;    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;Scheduler::run() exit&quot;;&#125;\n\n作用：\n首先，setThis() 函数会使得调度器创建的每个线程都有个静态线程局部变量 t_schedule 指向调度器 Scheduler。\n如果当前线程 id 不等于调度线程的 id，则需要创建当前线程的主协程。\n之后每个线程还需要创建懒惰协程 idle，入口函数为 idle()，每个懒惰协程先让出执行权。\n然后，本线程会进入到 while 循环中，持续判断任务队列 m_task 中是否有任务存在。如果当前线程已经取到了任务 task，但是任务队列 m_task 中还有任务 task 的话。则需要通知其他线程来进行干活。\n最后，将 cpu 的执行时间切换到 task 所保存的 协程 或者 回调函数，使该 task 对应的协程执行，resume 返回时，协程要么执行完了，要么半路yield了，总之这个任务就算完成了，活跃线程数减一。如果没有取到 task 的话，先判断当前调度器是否停止？如果没有停止的话，则切换到 idle 协程来执行对应的 idle()，当 idle 协程执行完时，当前线程就又需要重新进行抢夺任务来执行。\n\n\n\nidle() 函数  void Scheduler::idle()&#123;    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;idle&quot;;    while(!stopping())    &#123;        sylar::Fiber::GetThis()-&gt;yield();    &#125;&#125;\n\n作用：\n后面的模块会有继承 Scheduler 的类，其会修改 idle() 函数，用来执行线程没事的时候具体需要做些什么事情，而 Schedluer 这里只是简单的让 idle 协程让出执行权。\n\n\n\nstop 函数  void Scheduler::stop()&#123;    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;stop&quot;;    if (stopping())    &#123;      return;    &#125;    m_stopping = true;    // 判断是否使用了caller线程    if (m_useCaller)    &#123;      SYLAR_ASSERT(GetThis() == this);    &#125;    else    &#123;      SYLAR_ASSERT(GetThis() != this);    &#125;    for (size_t i = 0; i &lt; m_threadCount; i++)    &#123;      tickle();    &#125;    if (m_rootFiber)    &#123;      tickle();    &#125;    // 在use caller情况下，调度器协程结束时，应该返回caller协程    if (m_rootFiber)    &#123;      m_rootFiber-&gt;resume();      SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;m_rootFiber end&quot;;    &#125;    std::vector&lt;Thread::ptr&gt; thres;    &#123;      MutexType::Lock lock(m_mutex);      thres.swap(m_threads);    &#125;        for (auto&amp; i : thres)    &#123;      i-&gt;join();    &#125;    &#125;\n\n作用：stop 函数主要用于优雅停止调度器：它不是立刻杀掉线程，而是发出停止信号，唤醒所有调度线程&#x2F;协程让它们自行退出调度循环，最后 join() 等待线程池完全结束，确保 stop 返回时调度器已经干净停机。\n提前返回：若 stopping() 已满足条件，直接返回，避免重复停止。\n置停止标志：置 m_stopping = true，让 run()/idle() 中的 stopping() 判断最终变为真，从而退出循环。\n断言校验调用上下文：通过 GetThis()  检查当前线程是否符合 use_caller 语义，避免在错误线程上下文里触发停止逻辑导致协程切换混乱。\ntickle 唤醒：循环调用 tickle()用于叫醒可能在 idle()&#x2F;等待中的调度线程，让它们尽快回到 run() 检查停止条件并退出，否则 join() 可能一直等。m_rootFiber 存在时额外 tickle，是为了兼顾 caller 线程上的调度协程。\nresume rootFiber：当 use_caller=true 时，caller 线程的调度循环跑在 m_rootFiber 中。m_rootFiber-&gt;resume() 是为了把控制权切回调度协程，让其继续执行 run() 并走到退出点（通常由 idle() 观察到 stopping() 后结束，run() 再 break 退出），从而正确回到 caller 主协程完成收尾。\n释放锁后 join：将 m_threads swap 到局部变量再逐个 join()，避免 join 时长时间持锁，保证 stop 返回时所有调度线程都已经退出。\n\n\n\n参考文章sylar 源码解析—协程模块\n从零开始重写sylar C++高性能分布式服务器框架\nC++高性能分布式服务器框架\n","categories":["项目实战","Sylar"],"tags":["sylar","协程调度模块"]},{"title":"定时器模块","url":"/2025/12/24/sylar/%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97/","content":"1️⃣ 什么是定时器定时器（ Timer ）本质上就是一种“按时间触发任务”的机制：你把一个任务 task 交给它，并告诉它“多久以后执行”或者“每隔多久执行一次”，定时器负责在合适的时间点把这个任务触发出来。\n\n你可以把 Timer 理解成一个“闹钟”，而 TimerManager 就是“闹钟管理器”：你只负责设定时间和要做的事，到点后由它统一唤醒并执行对应任务。\n\n在服务器&#x2F;网络框架（比如 Sylar ）里，定时器通常用来做这些事：\n\n超时控制：连接超时、读写超时、RPC 超时重试\n周期任务：心跳包、定期统计、定期清理缓存&#x2F;过期会话\n延迟执行：延迟关闭连接、延迟回收资源、延迟投递任务\n事件循环协作：让 epoll/select 等 I/O 等待不会“傻等”，而是能在最近的定时点醒来。具体来说，事件循环会通过 getNextTimer() 计算“距离最近一次定时任务还要等多久”，并把这个时间作为 epoll_wait 的 timeout，这样既能等待 I/O 事件，又不会错过定时器到期触发。\n\n2️⃣ 整体框架\n3️⃣ 定时器模块私有成员\nm_ms：执行周期\nm_next: 精确的执行时间\nm_cb：定时器绑定的回调任务\nm_manager：定时器管理类\nrecurring：是否是循环定时器\n\n重要成员函数\n构造函数\nTimer::Timer(bool recurring, uint64_t ms, std::function&lt;void()&gt; cb, TimerManager* manager)  : recurring(recurring)  , m_ms(ms)  , m_cb(cb)  , m_manager(manager)&#123;  m_next = sylar::GetCurrentMS() + m_ms ;&#125;\n\n作用\n当前定时器的触发时间：\nm_next = GetCurrentMS() + m_ms\n含义：从当前时间起延迟 m_ms 毫秒执行回调 m_cb\n\n\n\n\n\n\ncancel\nbool Timer::cancel()&#123;  // 在多线程环境下，可能有多个线程会对 TimerManager 进行操作，所以需要加锁  TimerManager::RWMutexType::WriteLock Lock(m_manager-&gt;m_mutex);  if (m_cb)   // 判断定时器是否有回调任务，没有直接返回false  &#123;      // 如果有回调任务，将其置空       m_cb = nullptr;      // 在TimerManager中寻找Timer，将其删除      auto it = m_manager-&gt;m_timers.find(shared_from_this());      if (it != m_manager-&gt;m_timers.end())      &#123;          // 这说明找到了，将其从中删除          m_manager-&gt;m_timers.erase(it);      &#125;      return true;     &#125;  return false;&#125;\n\n作用\n这个函数主要用于取消当前定时器，让它不再被触发执行，并把它从 TimerManager 的定时器集合中移除。\n\n\n\n\nrefresh\nbool Timer::refresh()&#123;  TimerManager::RWMutexType::WriteLock Lock(m_manager-&gt;m_mutex);  if (!m_cb)  &#123;      return false;  &#125;  // 这说明定时器绑定了回调函数  auto it = m_manager-&gt;m_timers.find(shared_from_this());  if (it != m_manager-&gt;m_timers.end())  &#123;      // 这说明定时器列表中存在该定时器，将其从中删除      m_manager-&gt;m_timers.erase(it);      // 重置执行时间      m_next = sylar::GetCurrentMS() + m_ms;      // 将该定时器重新添加到定时器列表中      m_manager-&gt;m_timers.insert(shared_from_this());      return true;  &#125;  return false;&#125;\n\n作用\n这个函数主要用于刷新当前定时器以及定时器绑定的时间，并把它重新插入到 TimerManager。\n\n\n\n\nreset\nbool Timer::reset(uint64_t ms, bool from_now)&#123;  // 这说明定时器的时间间隔相同，而且不从现在开始重新及时  if (ms == m_ms &amp;&amp; !from_now)  &#123;      return true;  &#125;  // 添加锁来进行线程之间的同步  TimerManager::RWMutexType::WriteLock Lock(m_manager-&gt;m_mutex);  if (!m_cb)  &#123;      return false;  &#125;  auto it = m_manager-&gt;m_timers.find(shared_from_this());  if (it == m_manager-&gt;m_timers.end())  &#123;      return false;  &#125;  m_manager-&gt;m_timers.erase(it);  // 重新计算时间  uint64_t start = 0;  if (from_now)   // 这说明定时器的触发时间是现在  &#123;      start = sylar::GetCurrentMS();  &#125;  else  &#123;      start = m_next - m_ms;  // 获得上次定时器的触发事件 -------&gt; m_next : 是下次定时器的触发时间，m_ms: 是定时器到下次触发时间的时间间隔  &#125;  m_ms = ms;  m_next = m_ms + start;  m_manager-&gt;addTimer(shared_from_this(), Lock);  return true;&#125;\n\n作用\n如果不要求从现在重新定时且前后两次定时的时间间隔相同，就直接返回。\n否则重新计算时间并添加到定时器集合。\n\n\n\n\n\n4️⃣ 定时器管理模块私有成员\nm_mutex：读写锁互斥量\nm_timers：定时器集合\nm_previousTime：上次定时器执行时间\nm_tickled：避免了在插入新的最早定时器时，每次都重新触发通知，而只会在第一次插入时处理它\n\n重要成员函数\n构造函数\n  TimerManager::TimerManager()&#123;    m_previousTime = GetCurrentMS();&#125;\n\n作用\n记录 TimerManager 被创建时的系统运行时间（以毫秒为单位），用于后续定时器逻辑中检测系统时间是否出现回退、跳变等问题。\n\n\n\n\naddTimer\nTimer::ptr TimerManager::addTimer(uint64_t ms, bool recurring, std::function&lt;void()&gt; cb)&#123;    // 构造一个定时器    Timer::ptr timer(new Timer(recurring, ms, cb, this));    // 创建一个写者锁    TimerManager::RWMutexType::WriteLock Lock(m_mutex);    // 将定时器添加到定时器列表中    addTimer(timer,Lock);    // 返回定时器    return timer;&#125;\n\nvoid TimerManager::addTimer(Timer::ptr val, RWMutexType::WriteLock&amp; Lock)&#123;    auto it = m_timers.insert(val).first;    bool at_front = (it == m_timers.begin()) &amp;&amp; !m_tickled;    if(at_front)     &#123;        m_tickled = true;    &#125;    Lock.unlock();    if(at_front)     &#123;        onTimerInsertAtFront();     &#125;&#125;\n\n作用\n通过设置的时间间隔 ms，创建一个定时器 Timer，并将其添加到定时器集合 m_timers。\n如果这个新插入的定时器位于定时器集合中的最开始位置，即这个定时器最早到期。那么就必须通知 IO 线程提前醒来，比如：\n原来最早到期：还有 5000ms。\n现在插入了一个更早到期的 timer：只剩 10ms。\n如果不唤醒 IO 线程，它还会继续睡到 5000ms 才醒 → 这个 10ms 的 timer 就会被延迟执行。\n\n\n为什么需要 m_tickled？\nm_tickled == false：说明当前还没有“唤醒请求”在路上\n第一个插到最前面的 timer 负责唤醒，并把 m_tickled 置为 true\n\n\nm_tickled == true：说明已经有人触发过唤醒了（IO 线程马上就会醒&#x2F;正在醒）\n后续再插更早的 timer 不需要重复唤醒，因为 IO 线程醒来后会看到集合里最新最早的那个 timer。\n\n\n\n\n\n\n\n\naddTimerCondition\nTimer::ptr TimerManager::addTimerCondition(uint64_t ms, bool recurring, std::function&lt;void()&gt; cb, std::weak_ptr&lt;void&gt; weak_cond)&#123;    return addTimer(ms, recurring, std::bind(&amp;onTimer,weak_cond, cb));&#125;\nonTimer\nstatic void onTimer(std::weak_ptr&lt;void&gt; weak_cond, std::function&lt;void()&gt; cb)&#123;    // 这用来检测智能指针的指向的对象是否存在(通过弱智能指针weak_ptr不会使引用计数 + 1的特点)    std::shared_ptr&lt;void&gt; tmp = weak_cond.lock();    if (tmp)    &#123;        cb();    &#125;&#125;\n\n作用：\n添加一个条件定时器——只有当某个对象（由 weak_cond 指向）仍然存活时，定时器到期才会真正执行回调 cb；如果对象已经析构，则回调不会执行，相当于自动失效。\n\n\n\n\nlistExpireCb\nvoid TimerManager::listExpireCb(std::vector&lt;std::function&lt;void()&gt;&gt;&amp; cbs)&#123;    // 获得系统到现在的总时间    uint64_t now = GetCurrentMS();    // 定义一个超时定时器的列表，用来存放时间超过现在的定时器    std::vector&lt;Timer::ptr&gt; expired;    // 通过加读锁来判断当前定时器列表是否为空    &#123;        RWMutexType::ReadLock Lock(m_mutex);        if (m_timers.empty())        &#123;            return;        &#125;    &#125;    // 因为要对定时器列表进行删除，所以加写锁来进行控制、    RWMutexType::WriteLock Lock(m_mutex);    if (m_timers.empty())    &#123;        return;    &#125;    // 定义回滚变量    bool rollover = false;    // 检测是否出现回滚    if (detectClockRollover(now))    &#123;        rollover = true;    &#125;    // 这说明没有出现回滚，但是最近的定时器的触发时间都大于当前系统时间    if (!rollover &amp;&amp;  ((*m_timers.begin())-&gt;m_next &gt; now))    &#123;        return;    &#125;    // 定义一个当前时间的定时器    Timer::ptr nowTimer(new Timer(now));    // 根据是否回滚来执行不同的操作    auto it = rollover ? m_timers.end() : m_timers.lower_bound(nowTimer);    // 找到第一个大于当前时间的定时器    while(it != m_timers.end() &amp;&amp; (*it)-&gt;m_next == now)    &#123;        ++it;    &#125;    // 将超时定时器全部添加到超时计时器列表中    expired.insert(expired.begin(), m_timers.begin(), it);    // 将超时定时器从原来的列表中删除    m_timers.erase(m_timers.begin(), it);    // 给回调函数集合扩容    cbs.resize(expired.size());    // 遍历超时定时器集合，将超时定时器的回调函数全部添加到回调函数集合中    for (auto&amp; timer : expired)    &#123;        cbs.push_back(timer-&gt;m_cb);        // 判断是不是循环定时器        if (timer-&gt;recurring)        &#123;            timer-&gt;m_next = now + timer-&gt;m_ms;            m_timers.insert(timer);        &#125;        else        &#123;            timer-&gt;m_cb = nullptr;        &#125;     &#125; &#125;\n\n作用\n批量取出当前已经到期的定时器回调，把它们放进 cbs 供外部执行\n把这些到期定时器从管理器中移除\n对循环定时器重新计算下一次触发时间再插回去；另外还处理“系统时间回拨”的特殊情况。\n\n\n\n\n\n参考文章：\n从零开始重写sylar C++高性能分布式服务器框架\nsylar源码解析—定时器模块\n\n","categories":["项目实战","Sylar"],"tags":["sylar","定时器模块"]},{"title":"协程模块","url":"/2025/12/20/sylar/%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97/","content":"1️⃣ 什么是协程？协程是一种比线程更轻量级的用户态并发单位，可以在一个线程内部并发执行多个任务，并且支持在任务之间进行主动挂起与恢复，从而实现看起来像并行实际上是串行的异步逻辑。\n\n2️⃣ ucontext在 sylar 框架中，协程 Fiber 是基于 Linux 提供的 &lt;ucontext.h&gt; 实现的，该头文件中的 API 提供了保存、切换、恢复程序执行上下文的能力，允许用户在用户态实现轻量级的协程调度机制。\n概述ucontext 是 POSIX 标准中定义的一组函数，用于实现用户级上下文切换。它允许程序保存和恢复执行上下文（如寄存器、程序计数器、栈等），常用于实现协程、轻量级线程或任务调度等功能。以下是对 ucontext 的详细介绍，并结合代码进行说明。\nucontext 是实现协程的一种方式。因为协程本质上就是一种用户级的线程, 既然是一种特殊的线程, 其上下文切换的实现方式应该和线程的上下文切换类似, 也需要保存必要的寄存器、程序计数器、栈等信息。\n核心功能ucontext 提供了一种在用户空间管理执行上下文的方式，避免了内核级线程切换的开销。它的核心功能包括：\n\n保存当前执行上下文。\n恢复之前保存的上下文。\n创建新的执行上下文。\n在上下文之间切换。\n\n核心数据结构 ucontext_tucontext_t 是 ucontext 的核心数据结构，定义如下：\ntypedef struct ucontext &#123;    struct ucontext *uc_link;     // 指向下一个上下文    sigset_t         uc_sigmask;  // 信号掩码    stack_t          uc_stack;    // 栈信息    mcontext_t       uc_mcontext; // 机器上下文（寄存器等）    // 其他实现相关的字段&#125; ucontext_t;\n核心函数getcontext : 保存当前上下文int getcontext(ucontext_t *ucp);\n\n功能: 将当前执行上下文保存到 ucp 指向的 ucontext_t 结构体中。\n返回值: 成功返回 0，失败返回 -1。\n用途: 通常用于保存当前状态，以便后续恢复。\n\nsetcontext : 恢复上下文int setcontext(const ucontext_t *ucp);\n\n功能: 从 ucp 指向的 ucontext_t 结构体恢复上下文。\n返回值: 如果成功，不会返回；如果失败，返回 -1。\n用途: 用于跳转到之前保存的上下文。\n\nmakecontext : 创建新上下文void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);\n\n功能: 为 ucp 设置一个新的上下文，指定入口函数 func 和参数。\n参数:\nucp : 需要初始化的上下文。\nfunc : 新上下文的入口函数。\nargc : 传递给 func 的参数个数。\n... : 具体的参数值。\n\n\n用途: 用于跳转到之前保存的上下文。\n\nswapcontext : 切换上下文int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);\n\n功能: 保存当前上下文到 oucp，并切换到 ucp 指定的上下文。\n返回值: 如果成功，不会返回；如果失败，返回 -1。\n用途: 用于在两个上下文之间切换。\n\n3️⃣ 整体框架\n模块解析私有成员\nm_id：协程 id\nm_stacksize：协程栈的大小\nm_ctx：协程上下文\nm_stack：协程栈地址 \nm_cb：协程入口函数\nm_state：协程的状态，主要有 Ready，RUNNING，TERM 组成\nm_runInScheduler：本协程是否参与调度器 Scheduler 调度\n\n全局变量\ns_fiber_id: \n类型：static std::atomic&lt;uint64_t&gt; \n作用：全局静态变量，帮助生成协程 id\n\n\ns_fiber_count\n类型：static std::atomic&lt;uint64_t&gt;\n作用：全局静态变量，帮助统计协程的数量\n\n\nt_fiber\n类型：static thread_local Fiber*\n作用：静态线程局部变量，表示当前线程正在运行的协程\n\n\nt_thread_fiber\n类型：static thread_local Fiber::ptr\n作用：静态线程局部变量，表示当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行。\n\n\n\n重要成员函数\nSetThis\nvoid Fiber::SetThis(Fiber *f)&#123;    t_fiber = f;&#125;\n\n作用：表示当前的协程为线程正在执行的协程，即设置线程局部变量 t_fiber\n\n\nGetThis\nFiber::ptr Fiber::GetThis()&#123;    if (t_fiber)    &#123;        return t_fiber-&gt;shared_from_this();    &#125;    Fiber::ptr main_fiber(new Fiber);    SYLAR_ASSERT(main_fiber.get() == t_fiber);    t_thread_fiber = main_fiber;    return t_fiber-&gt;shared_from_this();&#125;\n\n作用：\n返回当前线程正在执行的协程，即返回线程局部变量 t_fiber\n如果当前线程还未创建协程，则创建线程的第一个协程，且该协程为当前线程的主协程，其他协程都通过这个协程来调度。\n也就是说，其他协程结束时,都要切回主协程，由主协程重新选择新的协程进行 resume\n通过静态线程局部变量 t_thread_fiber 保存当前的线程的主协程。\n\n\n\n\n构造函数\n\nFiber() \nFiber::Fiber()&#123;    SetThis(this);    m_state = RUNNING;    if (getcontext(&amp;m_ctx))    &#123;        SYLAR_ASSERT2(false,&quot;getcontent&quot;);    &#125;    ++s_fiber_count;    m_id = s_fiber_id++;    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;Fiber::Fiber() main id = &quot; &lt;&lt; m_id;&#125;\n\n作用\n无参构造函数主要创建线程的第一个协程，该协程为线程的主协程。\n线程主协程在每个线程中由 GetThis() 懒初始化并保存在 t_thread_fiber 中，外部应通过 GetThis() 获取，不应手动构造。\n\n\n\n\nFiber(std::function&lt;void()&gt; cb, size_t stacksize, bool run_in_scheduler)\nFiber::Fiber(std::function&lt;void()&gt; cb, size_t stacksize, bool run_in_scheduler)    : m_id(s_fiber_id++)    , m_cb(cb)    , m_runInScheduler(run_in_scheduler) &#123;    ++s_fiber_count;    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();    m_stack = StackAllocator::Alloc(m_stacksize);    if (getcontext(&amp;m_ctx))    &#123;        SYLAR_ASSERT2(false, &quot;getcontext&quot;);    &#125;    m_ctx.uc_link = nullptr;    m_ctx.uc_stack.ss_sp = m_stack;    m_ctx.uc_stack.ss_size = m_stacksize;    makecontext(&amp;m_ctx, Fiber::MainFunc, 0);    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;Fiber::Fiber() id=&quot; &lt;&lt; m_id;&#125;\n\n作用\n有参构造函数主要用于创建子协程，该协程为线程主协程或者调度器主协程的子协程。\n分配规定大小的堆空间，将开辟的堆空间用作协程栈的起始地址\n通过 makecontext 把协程入口设置为 Fiber::MainFunc：切入该协程时从 MainFunc 开始执行，MainFunc 内部会调用用户传入的回调 m_cb，结束后将状态置为 TERM 并 yield 回主协程&#x2F;调度器。\n\n\n\n\n\n\n析构函数\nFiber::~Fiber()&#123;    SYLAR_LOG_INFO(g_logger) &lt;&lt; &quot;Fiber::~Fiber() id = &quot; &lt;&lt; m_id;    --s_fiber_count;    if (m_stack)    // 这说明有栈，这是个子协程    &#123;        SYLAR_ASSERT(m_state == TERM);        StackAllocator::DeAlloc(m_stack, m_stacksize);        SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;dealloc stack, id = &quot; &lt;&lt; m_id;    &#125;    else            // 这说明没栈，这是个主协程    &#123;        SYLAR_ASSERT(!m_cb);        SYLAR_ASSERT(m_state == RUNNING); // 主协程一定是执行状态        Fiber* cur = t_fiber;     // 当前协程就是自己        if (cur == this)        &#123;            SetThis(nullptr);        &#125;    &#125;    &#125;\n\n作用\n如果是子协程，说明 Fiber 有单独的协议栈，需要释放掉申请的堆空间。\n如果是主协程，说明 Fiber 共享线程本身的栈空间，因此不需要释放。\n清理当前线程所保存的线程局部变量 “当前指向的协程”，将其设置为 nullptr。\n\n\n\n\nreset\nvoid Fiber::reset(std::function&lt;void()&gt; cb)&#123;    SYLAR_ASSERT(m_stack);    SYLAR_ASSERT(m_state == TERM);    m_cb = cb;    if (getcontext(&amp;m_ctx))    &#123;        SYLAR_ASSERT2(false,&quot;getcontext&quot;);    &#125;    m_ctx.uc_link = nullptr;    m_ctx.uc_stack.ss_size = m_stacksize;    m_ctx.uc_stack.ss_sp = m_stack;    makecontext(&amp;m_ctx,Fiber::MainFunc,0);    m_state = READY;&#125;\n\n作用\n重置协程状态和入口函数，复用栈空间，不重新创建栈。\n\n\n\n\nresume\nvoid Fiber::resume()&#123;    SYLAR_ASSERT(m_state != TERM &amp;&amp; m_state != RUNNING);    SetThis(this);    m_state = RUNNING;    // 如果协程参与调度器调度，那么应该和调度器的主协程进行swap，而不是线程主协程    if (m_runInScheduler)     &#123;        if (swapcontext(&amp;(Scheduler::GetMainFiber()-&gt;m_ctx), &amp;m_ctx))        &#123;            SYLAR_ASSERT2(false, &quot;swapcontext&quot;);        &#125;    &#125;     else     &#123;        if (swapcontext(&amp;(t_thread_fiber-&gt;m_ctx), &amp;m_ctx))         &#123;            SYLAR_ASSERT2(false, &quot;swapcontext&quot;);        &#125;    &#125;&#125;\n\n作用\n设置线程正在执行的协程为当前协程以及协程状态为 RUNNING\n如果协程参与调度器调度，那么应该和调度器的主协程进行 swap，而不是线程主协程。\n\n\n\n\nyield\nvoid Fiber::yield()&#123;    // 协程运行完之后会自动yield一次，用于回到主协程，此时状态已为结束状态    SYLAR_ASSERT(m_state == RUNNING || m_state == TERM);    if (m_state != TERM)     &#123;        m_state = READY;    &#125;    // 如果协程参与调度器调度，那么应该和调度器的主协程进行swap，而不是线程主协程    if (m_runInScheduler)     &#123;        SetThis(Scheduler::GetMainFiber());        if (swapcontext(&amp;m_ctx, &amp;(Scheduler::GetMainFiber()-&gt;m_ctx)))         &#123;            SYLAR_ASSERT2(false, &quot;swapcontext&quot;);        &#125;    &#125;     else     &#123;        SetThis(t_thread_fiber.get());        if (swapcontext(&amp;m_ctx, &amp;(t_thread_fiber-&gt;m_ctx)))         &#123;            SYLAR_ASSERT2(false, &quot;swapcontext&quot;);        &#125;    &#125;&#125;\n\n作用\n当前协程重置自己的状态为 READY。\n如果协程参与调度器调度，和调度器的主协程进行切换，让出自己的执行权。\n如果协程不参与调度器调度，和线程的主协程进行切换，让出自己的执行权力。\n\n\n\n\nMainFunc\nvoid Fiber::MainFunc()&#123;    Fiber::ptr cur = GetThis();    SYLAR_ASSERT(cur);    cur-&gt;m_cb();    cur-&gt;m_cb    = nullptr;    cur-&gt;m_state = TERM;    auto raw_ptr = cur.get(); // 手动让t_fiber的引用计数减1    cur.reset();    raw_ptr-&gt;yield();    SYLAR_ASSERT2(false, &quot;never reach fiber_id=&quot; + std::to_string(raw_ptr-&gt;getId()));&#125;\n\n作用\n该函数为协程入口函数，用于每个子协程执行自己所绑定的函数，并重置子协程的状态为 TERM，最后让出执行权限。\n\n\n\n\n\n参考文章：sylar 源码解析—协程模块\nucontext 学习\n从零开始重写sylar C++高性能分布式服务器框架\nC++高性能分布式服务器框架\n","categories":["项目实战","Sylar"],"tags":["sylar","协程模块"]},{"title":"IOManager 模块","url":"/2025/12/26/sylar/IOManager/","content":"1️⃣ 什么是 IOManager 模块IOManager 模块可以理解为 Sylar 框架里的“协程版 I/O 事件循环 + 调度中枢”。它把 Linux 的 epoll 事件机制和协程调度器 Scheduler 融合在了一起。\n\n当某个文件描述符 socket、pipe 等变得可读&#x2F;可写时，IOManager 不会像传统 Reactor 那样直接在 epoll 线程里执行回调，而是把对应的回调函数或协程 Fiber 重新投递到调度器队列中，由线程池里的工作线程去执行。这样一来，业务逻辑可以用“同步写法”的协程风格组织，却能获得“异步 I&#x2F;O”的高并发能力。\n\n更具体地说，IOManager 维护了一个 FdContext 表，用来记录每个 fd 关注的读&#x2F;写事件以及事件触发后要执行的回调函数或等待中的协程。它内部的 idle() 协程长期阻塞在 epoll_wait 上\n\n一旦事件到来，就通过 triggerEvent() 将任务调度出去；同时它还继承 TimerManager，把定时器超时回调也纳入同一套调度体系，实现“IO 事件 + 定时任务”的统一驱动。为了在新增任务或定时器更新时及时唤醒 epoll_wait，IOManager 还使用 pipe 的 tickle 机制向 epoll 注入一个可读事件，让空闲线程立刻从阻塞中返回，继续处理新的调度工作。\n\n2️⃣ 整体框架\n3️⃣ 嵌套类enum Eventenum Event&#123;    NONE = 0x0,    READ = 0x1,    WRITE = 0x4&#125;;\nenum Event 用来表示 IOManager 关心的 I/O 事件类型，并且用位标志（bitmask）的方式存储&#x2F;组合它们\n\nNONE = 0x0：不关注任何事件\nREAD = 0x1：关注“可读事件”（比如 socket 有数据可读 &#x2F; pipe 可读 &#x2F; 接收缓冲区有数据）\nWRITE = 0x4：关注“可写事件”（比如 socket 发送缓冲区有空间，可以继续发送）\n\nstrcut EventContextstruct EventContext&#123;    Scheduler* scheduler = nullptr;    std::function&lt;void()&gt; cb;    Fiber::ptr fiber;           &#125;;\nEventContext 的作用就是：描述“某个 fd 的某个事件（READ 或 WRITE）触发后，该由哪个调度器 Scheduler 去执行什么回调函数或协程”。\n\nscheduler\n记录事件触发后要把任务投递到哪个调度器 Scheduler 里执行（通常就是当前线程的 Scheduler::GetThis()）。因为 IOManager 可能有多个调度线程，必须知道回到哪个调度器。\n\n\ncb\n如果用户在 addEvent(fd, event, cb) 传了回调，那么事件就绪时执行这个回调函数。\n\n\nfiber\n如果用户没有传回调，会把协程存进来，事件触发时就把这个协程重新 schedule()，从而实现“协程等待 IO → IO 就绪后继续跑”。\n\n\n\nstruct FdContextstruct FdContext&#123;    using MutexType = Mutex;    /**     *  @brief 事件绑定的回调函数      */    struct EventContext    &#123;        Scheduler* scheduler = nullptr;        std::function&lt;void()&gt; cb;        Fiber::ptr fiber;               &#125;;    /**     * @brief 获取事件上下文类     * @param[in] event 事件类型     * @return 返回对应事件的上下文     */    EventContext&amp; getEventContext(Event event);    /**     * @brief 重置事件上下文     * @param[in, out] ctx 待重置的事件上下文对象     */    void resetEventContext(EventContext &amp;ctx);    /**     * @brief 触发事件     * @details 根据事件类型调用对应上下文结构中的调度器去调度回调协程或回调函数     * @param[in] event 事件类型     */    void triggerEvent(Event event);            int fd = 0;                     // 对应的文件描述符    EventContext read;              // 读事件    EventContext write;             // 写事件    Event m_events = NONE;          // 事件集（每一位对应读写事件）    MutexType m_mutex;              // 互斥锁&#125;;\nFdContext 的作用是：把一个文件描述符 fd 的“事件注册状态 + 事件触发后的执行体”完整封装起来，让 IOManager 能把 epoll 返回的事件，准确转换成“调度器要执行的协程&#x2F;回调”。\n\nFdContext 中的 m_event 记录当前这个 fd 注册了哪些事件\nm_event &amp; Read 表示在 fd 上注册了读事件\nm_event &amp; Write 表示在 fd 上注册了写事件\n\n\nFdContext 中的 EventContext 记录当前这个 fd 对应读写事件的回调函数 cb 和协程 fiber\ngetEventContext 用于根据事件 event 的类型，返回对应事件所注册的 EventContext。\ntriggerEvent 用于根据事件 event 的类型，将这个事件所注册的回调函数 cb 以及协程 fiber 加入到 EventContext 所保存的调度器 scheduler 中进行调度。\n\n4️⃣ 重要函数构造函数IOManager::IOManager(size_t threads, bool use_caller, const std::string &amp;name)    : Scheduler(threads, use_caller, name)&#123;    // 创建一个epoll实例，返回对应的内核事件表    m_epfd = epoll_create(5000);    SYLAR_ASSERT(m_epfd &gt; 0);    // 创建一个管道，返回对应的文件描述符(句柄)    int rt = pipe(m_tickleFds);    SYLAR_ASSERT(rt == 0);    // 创建一个epoll_event事件，用于联系 fd 和 fd 对应的读写事件    epoll_event event;    bzero(&amp;event,sizeof(event));    event.events = EPOLLIN | EPOLLET;    event.data.fd = m_tickleFds[0];    // 修改m_tickleFds[0]的属性为非阻塞模式    rt = fcntl(m_tickleFds[0],F_SETFL, O_NONBLOCK);    SYLAR_ASSERT(!rt);    // 往内核事件表上注册fd和其对应的事件    rt = epoll_ctl(m_epfd, EPOLL_CTL_ADD, m_tickleFds[0], &amp;event);    SYLAR_ASSERT(!rt);    // 默认设置64个大小    contextResize(32);    // 默认启动 协程调度器Scheduler    start();&#125;\nIOManager 继承自 Scheduler，因此在构造 IOManager 对象时，会先执行基类 Scheduler 的构造函数，完成调度器的基础初始化工作（例如线程数配置、是否使用 caller 线程、调度器名称设置等）。Scheduler 的完整初始化与运行机制我已在协程调度模块中详细展开，本文不再重复啰嗦，只保留与 IOManager 相关的部分作为铺垫。\n解析：\n首先，IOManager 的构造函数通过系统调用 epoll_create 建立内核事件表。\nm_epfd 是 epoll 的实例句柄，对应内核中的事件表。\n后续所有 fd 的读写事件监听，都会通过 epoll_ctl 注册到这个 epoll 实例中。\nidle() 协程则会阻塞在 epoll_wait(m_epfd, ...) 上等待事件发生（IO 就绪 &#x2F; tickle 唤醒 &#x2F; 超时返回）。\n\n\n其次，建立 tickle 机制：用 pipe 唤醒阻塞的 epoll_wait 的 idle 协程\nIOManager 最关键的问题之一是：当 idle 协程正阻塞在 epoll_wait 时，如何让它立刻返回去重新检查调度队列？\n\nSylar 中的实现是使用一对 pipe 来作为唤醒管道\nint rt = pipe(m_tickleFds);SYLAR_ASSERT(rt == 0);\n\n\nm_tickleFds[0]：读端（注册进 epoll）\nm_tickleFds[1]：写端（tickle 时写入一个字节）\n\n\n\n\n之后，会将读端注册到 epoll，这里监听的是 EPOLLIN（可读事件发生），并使用 EPOLLET（边缘触发）。\n由于执行 Scheduler::run() 的线程发现任务队列 m_task 没有任务的时候，会执行协程 idle()，陷入到 epoll_wait 中等待事件的发生。\n但是当其他线程执行 Scheduler::run() 发现除了自己执行的任务之外还有任务的时候，会调用 tickle() 往写端写入数据时，此时读端变得可读，idle 协程就会从 epoll_wait 立刻返回，从而唤醒 idle。idle() 协程会在本轮完成事件分发：将 IO 就绪事件&#x2F;超时定时器对应的 fiber/cb 重新 schedule() 投递回调度器队列；随后 yield() 让出执行权，由 Scheduler::run() 再去真正执行这些任务。\n为了避免读端阻塞，还需要把读端设为非阻塞模式。\n\n\n然后，初始化 fd 上下文表：建立 fd → FdContext 的映射  contextResize(32);\n\nm_fdcontexts 是一个 “fd 下标 → FdContext” 的数组结构。\n构造阶段先预分配一段容量，后续 addEvent(fd, ...) 时如果 fd 更大，再动态扩容。\n\n\n最后，启动调度器：让 IOManager 正式开始工作  start();\n\n这一步会启动 Scheduler 的工作线程，并进入调度循环。之后 IOManager 的 idle() 协程会在空闲时阻塞在 epoll_wait，等待 IO 事件或 tickle 唤醒；一旦事件发生，就将对应的 fiber/cb 投递回调度器执行。\n\n\n\ncontextResize 函数void IOManager::contextResize(size_t size)&#123;    m_fdcontexts.resize(size);    for (size_t i = 0; i &lt; m_fdcontexts.size(); i++)    &#123;        if (!m_fdcontexts[i])        &#123;            m_fdcontexts[i] = new FdContext;            m_fdcontexts[i]-&gt;fd = i;        &#125;    &#125; &#125;\n作用是：扩容并初始化 IOManager 的 fd 上下文表 m_fdcontexts，建立 “fd → FdContext” 的映射，保证后续对某个 fd 注册事件时，能快速拿到对应的 FdContext。\ntickle 函数void IOManager::tickle()&#123;    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;tickle&quot;;    if (!hasIdleThreads())    &#123;        return;    &#125;    int rt = write(m_tickleFds[1], &quot;T&quot;, 1);    SYLAR_ASSERT(rt == 1);&#125;\nIOManager::tickle() 的作用是：唤醒可能正在 epoll_wait 中阻塞的空闲线程（idle 协程），让调度器立刻重新检查任务队列&#x2F;定时器，从而及时调度新任务。\n它做法很经典：往 pipe 管道写一个字节制造“可读事件”。\naddEvent 函数int IOManager::addEvent(int fd, Event event, std::function&lt;void()&gt; cb)&#123;    FdContext* fd_ctx = nullptr;    RWMutexType::ReadLock lock(m_mutex);    if ((int)m_fdcontexts.size() &gt; fd)    &#123;        fd_ctx = m_fdcontexts[fd];        lock.unlock();    &#125;    else    &#123;        lock.unlock();        RWMutexType::WriteLock lock2(m_mutex);        contextResize(fd * 1.5);        fd_ctx = m_fdcontexts[fd];    &#125;    // 同一个fd不允许重复添加相同的事件    FdContext::MutexType::Lock lock3(fd_ctx-&gt;m_mutex);    if (SYLAR_UNLIKELY(fd_ctx-&gt;m_events &amp; event))   // 这表示事件类型重复，比如都是读事件    &#123;        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;addEvent assert fd=&quot; &lt;&lt; fd                                  &lt;&lt; &quot; event=&quot; &lt;&lt; event                                  &lt;&lt; &quot; fd_ctx.event=&quot; &lt;&lt; fd_ctx-&gt;m_events;        SYLAR_ASSERT(!(fd_ctx-&gt;m_events &amp; event));    &#125;        // 将新的事件加入epoll_wait，使用epoll_event的私有指针存储FdContext的位置    int op = fd_ctx-&gt;m_events ? EPOLL_CTL_MOD : EPOLL_CTL_ADD;    epoll_event epevent;    epevent.events = EPOLLET | static_cast&lt;EPOLL_EVENTS&gt;(fd_ctx-&gt;m_events) | static_cast&lt;EPOLL_EVENTS&gt;(event);    epevent.data.ptr = fd_ctx;    int rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);    if (rt)    &#123;        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;epoll_ctl(&quot; &lt;&lt; m_epfd &lt;&lt; &quot;, &quot;        &lt;&lt; op &lt;&lt; &quot;, &quot; &lt;&lt; fd &lt;&lt; &quot;, &quot; &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; &quot;):&quot;        &lt;&lt; rt &lt;&lt; &quot; (&quot; &lt;&lt; errno &lt;&lt; &quot;) (&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;) fd_ctx-&gt;events=&quot;        &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;m_events;        return -1;    &#125;        // 待执行IO事件数加1    ++m_pendingEventCount;    // 找到这个fd的event事件对应的EventContext，对其的scheduler、fiber、cb进行赋值    fd_ctx-&gt;m_events = static_cast&lt;Event&gt;(fd_ctx-&gt;m_events | event);    FdContext::EventContext&amp; event_ctx = fd_ctx-&gt;getEventContext(event);    SYLAR_ASSERT(!event_ctx.scheduler &amp;&amp; !event_ctx.fiber &amp;&amp; !event_ctx.cb);    // 赋值scheduler和回调函数，如果回调函数为空，则把当前协程当成回调执行体    event_ctx.scheduler = Scheduler::GetThis();    if (cb)    &#123;        event_ctx.cb.swap(cb);    &#125;    else    &#123;        event_ctx.fiber = Fiber::GetThis();        SYLAR_ASSERT2(event_ctx.fiber-&gt;getState() == Fiber::RUNNING, &quot;state=&quot; &lt;&lt; event_ctx.fiber-&gt;getState());    &#125;        return 0;&#125;\nIOManager::addEvent 的作用是：在指定 fd 上注册一个 IO 事件（READ/WRITE）到 epoll，同时把“事件触发后要执行的内容”绑定到该 fd 的上下文里。这样当 epoll 检测到该 fd 就绪时，IOManager 就能把对应的 cb 或 fiber 投递回 Scheduler 去执行。\n解析\n首先，创建或者定位 fd 对应的 FdContext。\n如果 m_fdcontexts 的容量够用，直接返回 fd 对应的 FdContext。\n否则，对 m_fdcontexts 进行扩容，再返回 fd 对应的 FdContext。\n\n\n其次，保证不允许对同一 fd 重复注册同一种事件。\n然后，将对 fd 的事件注册到 epoll\n先决定操作类型 op：\n若该 fd 之前没有注册过任何事件：EPOLL_CTL_ADD\n若已有 fd 之前注册过事件 event，比如之前已注册 READ，现在加 WRITE：EPOLL_CTL_MOD\n\n\n构造 epoll_event\nepevent.events = EPOLLET | 旧事件 | 新事件\nepevent.data.ptr = fd_ctx，这里非常重要，因为当 epoll 检测到该 fd 就绪后，可以直接通过 epoll_event.data.ptr 找到注册到这个事件的协程&#x2F;回调函数 fiber/cb\n\n\n调用 epoll_ctl 注册&#x2F;修改内核事件表 m_epfd 监听该 fd 的所关注事件。\n\n\n之后，通过 m_pendingEventCount 记录当前 “已注册但尚未触发” 的 IO 事件数，用于 stopping() 判断（是否还有 IO 事件挂着，不能退出）。\n最后，绑定事件触发后的执行体（cb 或 fiber）到 EventContext。\n更新 fd_ctx 关注的事件：fd_ctx-&gt;m_events |= event\n找到事件 event 对应的协程&#x2F;回调函数：EventContext&amp; event_ctx = getEventContext(event)\n绑定调度器：event_ctx.scheduler = Scheduler::GetThis();\n绑定执行体：\n如果传了 cb：保存回调函数，之后事件触发后就 schedule 这个 cb 函数\n如果没传 cb：保存当前协程 Fiber::GetThis()，表示“当前协程在等这个 IO 事件”。\n\n\n\n\n\ndelEvent 函数同理于 addEvent 函数，只不过作用相反\ncancelEvent 函数bool IOManager::cancelEvent(int fd, Event event)&#123;    // 找到fd对应的FdContext    RWMutexType::ReadLock lock(m_mutex);    if (m_fdcontexts.size() &lt;= fd) &#123;        return false;    &#125;    FdContext *fd_ctx = m_fdcontexts[fd];    lock.unlock();    FdContext::MutexType::Lock lock2(fd_ctx-&gt;m_mutex);    if (!(fd_ctx-&gt;m_events &amp; event)) &#123;        return false;    &#125;    // 删除事件    Event new_events = (Event)(fd_ctx-&gt;m_events &amp; ~event);    int op = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;    epoll_event epevent;    epevent.events   = EPOLLET | static_cast&lt;EPOLL_EVENTS&gt;(new_events);    epevent.data.ptr = fd_ctx;    int rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);    if (rt) &#123;        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;epoll_ctl(&quot; &lt;&lt; m_epfd &lt;&lt; &quot;, &quot;                                  &lt;&lt; op &lt;&lt; &quot;, &quot; &lt;&lt; fd &lt;&lt; &quot;, &quot; &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; &quot;):&quot;                                  &lt;&lt; rt &lt;&lt; &quot; (&quot; &lt;&lt; errno &lt;&lt; &quot;) (&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;)&quot;;        return false;    &#125;    // 删除之前触发一次事件    fd_ctx-&gt;triggerEvent(event);    // 活跃事件数减1    --m_pendingEventCount;    return true;&#125;\n该函数主要用于取消某个 fd 上已经注册的指定事件（READ/WRITE），把它从 epoll 的监听集合里移除，同时“主动触发一次”该事件对应的 cb/fiber，让等待它的任务立刻被调度执行（通常用于唤醒正在等待 IO 的协程，避免永远挂起）\n解析fd_ctx-&gt;triggerEvent(event);\n首先，addEvent 的本质：不是“监听” ，而是“挂起一个等待者”\n\n当调用 addEvent(fd, READ) [不传 cb]时，典型使用方式是：\naddEvent 把当前协程保存到 &#96;fd_ctx-&gt;read.fiber\n然后当前协程 yield()，让出执行权\n等 READ 就绪时，IOManager 才会 schedule(fiber) 把它恢复。所以这个 fiber 现在的状态是：我在等 READ 才能继续。\n\n\n\n其次，如果只“取消监听”，但不唤醒，会发生什么？\n\n这个协程已经 yield() 了，它不会自己醒。\n你又把 epoll 监听删了，未来也不会再触发 READ\n结果这个协程永远不会被恢复（逻辑死锁&#x2F;资源泄漏）\n\ncancelAll 函数同理于 cancelEvent 函数，主要用于取消 fd 关注的所有事件。\nidle 函数IOManager 最重要的函数：主要描述了一个线程在无法在任务队列 m_task 取得任务 task 后，会将执行权给 idle 协程，idle 协程会给出线程在空闲时会做些什么！\nvoid IOManager::idle()&#123;    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;idle&quot;;    // 一次epoll_wait 最多检测256个就绪事件，如果就绪事件超过了这个数，那么会在下轮epoll_wait继续处理    const uint64_t MAX_EVENTS = 256;    epoll_event* events = new epoll_event[MAX_EVENTS]();    std::shared_ptr&lt;epoll_event&gt; shared_events(events, [](epoll_event* ptr)&#123;        delete[] ptr;    &#125;);    while(true)    &#123;        // 获取下一个定时器的超时时间，顺便判断调度器是否停止        uint64_t next_timeout = 0;        if (SYLAR_UNLIKELY(stopping(next_timeout)))        &#123;            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; &quot;name= &quot; &lt;&lt; getName() &lt;&lt; &quot; idle stopping exit&quot;;            break;        &#125;                // 阻塞在epoll_wait上，等待事件发生或定时器超时        int rt = 0;        do        &#123;            // 默认超时时间5秒，如果下一个定时器的超时时间大于5秒，仍以5秒来计算超时，避免定时器超时时间太大时，epoll_wait一直阻塞            static const int TIMEOUT = 5000;            if(next_timeout != ~0ull)             &#123;                next_timeout = std::min((int)next_timeout, TIMEOUT);            &#125;             else             &#123;                next_timeout = TIMEOUT;            &#125;            rt = epoll_wait(m_epfd, events, MAX_EVENTS, (int)next_timeout);            if (rt &lt; 0 &amp;&amp; errno == EINTR)            &#123;                continue;            &#125;            else            &#123;                break;            &#125;         &#125; while (true);                // 收集所有已超时的定时器，执行回调函数        std::vector&lt;std::function&lt;void()&gt;&gt; cbs;        listExpireCb(cbs);        if(!cbs.empty())         &#123;            for(const auto &amp;cb : cbs)             &#123;                schedule(cb);            &#125;            cbs.clear();        &#125;        // 遍历所有发生的事件，根据epoll_event的私有指针找到对应的FdContext，进行事件处理        for (size_t i = 0; i &lt; rt; ++i)        &#123;            epoll_event&amp; event = events[i];            if (event.data.fd == m_tickleFds[0])            &#123;                // ticklefd[0] 用于通知协程调度，这时只需要把管道里的内容读完即可                uint8_t dummy[256];                while (read(m_tickleFds[0], dummy, sizeof(dummy)) &gt; 0)                    ;                continue;            &#125;            FdContext* fd_ctx = (FdContext*)event.data.ptr;            FdContext::MutexType::Lock lock(fd_ctx-&gt;m_mutex);             /**             * EPOLLERR: 出错，比如写读端已经关闭的pipe             * EPOLLHUP: 套接字对端关闭             * 出现这两种事件，应该同时触发fd的读和写事件，否则有可能出现注册的事件永远执行不到的情况             */             if (event.events &amp; (EPOLLERR | EPOLLHUP))            &#123;                event.events |= (EPOLLERR | EPOLLHUP) &amp; fd_ctx-&gt;m_events;            &#125;            int real_events = NONE;            if (event.events &amp; EPOLLIN)            &#123;                real_events |= READ;            &#125;            if (event.events &amp; EPOLLOUT)            &#123;                real_events |= WRITE;            &#125;            if ((fd_ctx-&gt;m_events &amp; real_events)  == NONE)            &#123;                continue;            &#125;            // 剔除已经发生的事件，将剩下的事件重新加入epoll_wait            int left_events = (fd_ctx-&gt;m_events &amp; ~real_events);            int op = left_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;            event.events = EPOLLET | left_events;            int rt2 = epoll_ctl(m_epfd, op, fd_ctx-&gt;fd, &amp;event);            if (rt2)            &#123;                SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;epoll_ctl(&quot; &lt;&lt; m_epfd &lt;&lt; &quot;, &quot;                                          &lt;&lt; op &lt;&lt; &quot;, &quot; &lt;&lt; fd_ctx-&gt;fd &lt;&lt; &quot;, &quot; &lt;&lt; (EPOLL_EVENTS)event.events &lt;&lt; &quot;):&quot;                                          &lt;&lt; rt2 &lt;&lt; &quot; (&quot; &lt;&lt; errno &lt;&lt; &quot;) (&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;)&quot;;                continue;            &#125;                        // 处理已经发生的事件件，也就是让调度器调度指定的函数或协程            if (real_events &amp; READ)            &#123;                fd_ctx-&gt;triggerEvent(READ);                --m_pendingEventCount;            &#125;            if (real_events &amp; WRITE) &#123;                fd_ctx-&gt;triggerEvent(WRITE);                --m_pendingEventCount;            &#125;        &#125;        /**         * 一旦处理完所有的事件，idle协程yield，这样可以让调度协程(Scheduler::run)重新检查是否有新任务要调度         * 上面triggerEvent实际也只是把对应的fiber重新加入调度，要执行的话还要等idle协程退出         */         Fiber::ptr cur = Fiber::GetThis();        auto raw_ptr   = cur.get();        cur.reset();        raw_ptr-&gt;yield();    &#125;&#125;\nIOManager::idle()作为IOManager 的“事件循环协程”。当调度器没有普通任务可跑时，线程会切换到 idle()，它负责：\n\n阻塞在 epoll_wait 上等待 IO 就绪或被 tickle 唤醒\n处理定时器超时，把超时回调投递到调度器队列\n把就绪的 READ/WRITE 事件对应的协程&#x2F;回调重新 schedule() 回调度器执行\n最后 yield() 让出执行权回到 Scheduler::run()，让调度器去真正执行刚投递的任务\n\n一句话：idle() 不执行业务逻辑，它只做 “等待 + 分发（投递）”。\n解析首先，准备 epoll 就绪事件数组 eventsconst uint64_t MAX_EVENTS = 256;epoll_event* events = new epoll_event[MAX_EVENTS]();\n\n一次 epoll_wait 最多处理 256 个就绪事件，超过的留到下一轮。\n\n其次，循环运行：直到满足停止条件\n通过 stopping(next_timeout) 获取下一个定时器时间作为 epoll_wait 的超时时间 timeout\n并且判断是否可以退出。\n\n阻塞等待：epoll_wait + timeoutrt = epoll_wait(m_epfd, events, MAX_EVENTS, (int)next_timeout);\n\n如果有 IO 就绪 &#x2F; tickle pipe 可读，立刻返回\n如果没有事件发生，但 timeout 到了，处理定时器\n被信号中断 EINTR 则重试\n最大阻塞时间为 5s，避免定时器很大导致线程长时间睡眠\n\n处理所有已超时的定时器：只投递，不执行std::vector&lt;std::function&lt;void()&gt;&gt; cbs;listExpireCb(cbs);if(!cbs.empty()) &#123;    for(const auto &amp;cb : cbs)     &#123;        schedule(cb);    &#125;    cbs.clear();&#125;\n\n主要是把定时器回调加入任务队列，真正执行要等 idle() yield 后回到 Scheduler::run()。\n\n遍历 epoll 返回的就绪事件：只分发，不执行对于每个 epoll_event 事件\n\n如果是 tickle 管道读端：tickle 的目的只是唤醒 idle 协程让出执行权，所以读空 pipe 传来的字节即可。\nif (event.data.fd == m_tickleFds[0])&#123;  // ticklefd[0] 用于通知协程调度，这时只需要把管道里的内容读完即可  uint8_t dummy[256];  while (read(m_tickleFds[0], dummy, sizeof(dummy)) &gt; 0)      ;  continue;&#125;\n如果是业务 fd\n\n找到对应的 FdContext，因为 FdContext 保存了 fd 关注的事件就绪后需要进行的 cb/fiber。 \n判断事件 event 类型\n如果是异常事件 EPOLLERR | EPOLLHUP，则将异常事件映射成 read/write 都就绪事件，避免等待在 read/write 的协程永远睡死。\n  if (event.events &amp; (EPOLLERR | EPOLLHUP))&#123;    event.events |= (EPOLLERR | EPOLLHUP) &amp; fd_ctx-&gt;m_events; &#125;\n如果是常规事件，则判断是读写事件，并且判断是否是 fd_ctx 保存的 fd 所感兴趣的事件。\n  int real_events = NONE;if (event.events &amp; EPOLLIN)&#123;    real_events |= READ;&#125;if (event.events &amp; EPOLLOUT)&#123;    real_events |= WRITE;&#125;\n剔除已经发生的事件，将剩下的事件重新加入 epoll_wait\n int left_events = (fd_ctx-&gt;m_events &amp; ~real_events);int op = left_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;event.events = EPOLLET | left_events;int rt2 = epoll_ctl(m_epfd, op, fd_ctx-&gt;fd, &amp;event);\n\n处理已发生的事件，将 fd 感兴趣的事件 event 要进行的 fiber/cb 放入到任务队列中。\n if (real_events &amp; READ)&#123;    fd_ctx-&gt;triggerEvent(READ);    --m_pendingEventCount;&#125;if (real_events &amp; WRITE) &#123;    fd_ctx-&gt;triggerEvent(WRITE);    --m_pendingEventCount;&#125;\n\n\n\n\n\n释放执行权给 Scheduler::run()一旦处理完所有的事件，idle 协程 yield，让出执行权，这样可以让调度协程 (Scheduler::run) 重新检查是否有新任务要执行。\n","categories":["项目实战","Sylar"],"tags":["sylar","IOManager 模块"]},{"title":"日志模块","url":"/2025/06/10/sylar/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/","content":"日志模块1️⃣ 日志的作用\n在服务器的运行过程中，日志可以记录服务器运行过程中的各种事件，所以日志是非常有作用的。\n记录服务器的启动和关闭\n记录客户端连接&#x2F;断开\n记录HTTP 请求的接收与响应\n记录协程调度执行情况\n记录异常或错误信息（如断网、文件打不开等）\n\n\n当运行过程中当出现异常行为（比如响应延迟、崩溃、死锁等）时，开发者可以通过日志快速定位问题所在：\n快速定位问题发生的代码逻辑\n分析错误发生的上下文（线程 ID、时间戳、调用路径等）\n重现问题流程\n\n\n在 sylar 服务器框架中，使用了类似 Log4cpp 的结构，支持多级日志输出，支持流式日志风格写日志和格式化风格写日志，支持日志格式自定义，日志级别，多日志分离等等功能\n\n2️⃣ 日志级别\n整体框架\n\nsylar 框架中主要使用 logLevel 表示日志级别\n\n\n日志等级\n\n日志等级主要根据严重程度，从大到小依次排序enum Level  &#123;      FATAL = 0,      // 致命情况，系统不可用      ALERT = 100,    // 高优先级情况，例如数据库系统崩溃      CRIT = 200,     // 严重错误，例如硬盘错误      ERROR = 300,    // 错误      WARN = 400,     // 警告      NOTICE = 500,   // 正常但值得注意      INFO = 600,     // 一般信息      DEBUG = 700,    // 调试信息      NOTSET = 800    // 未设置  &#125;;\n\n\n转换函数\n\n为了方便在代码里使用，sylar 在 logLevel 中提供了两个方法，用于将 Level 转换成字符串，或者将字符串转换成 Level 。 /**  * @brief 日志级别转字符串  * @param Level 日志级别  * @return string   字符串形式的日志级别  */  static const char* LevelToString(LogLevel::Level level);  /**  * @brief 字符串形式的日志级别转换成LogLevel::Level  * @param const char*   * @return LogLevel::Level  */static const LogLevel::Level StringToLevel(const std::string&amp; str);\n\n\n\n3️⃣ 日志事件\n整体框架\n\nsylar 中主要使用 LogEvent 表示一个日志事件\n\n\n\n\n主要成员\nLogLevel::Level m_level;    // 日志级别std::stringstream m_ss;     // 日志内容const char* m_filename = 0; // 文件名int32_t m_line = 0;         // 行号uint64_t m_elapse = 0;      // 从日志器创建到当前日志的时间uint32_t m_threadid = 0;    // 线程号uint64_t m_fiberid = 0;     // 协程号time_t m_time;              // 时间戳std::string m_threadName;   // 线程名称std::string m_loggerName;   // 日志器的名称\nLogEvent 中只有 get 方法用来提供对外的接口，返回对应的私有成员，例如：\nLogLevel::Level getLevel() const &#123; return m_level; &#125; \n\n4️⃣ 日志格式化器\nLogFormatter 作用\n\n在 sylar 框架中，LogFormatter 是日志系统的格式化核心模块。它负责将日志事件（LogEvent）格式化为字符串，使其能够以我们设定的格式输出到日志文件、控制台或其他日志输出目标。\n\n\n为什么需要 LogFormatter\n\n直接输出 LogEvent 结构体是不直观的，比如\nINFO 2025-06-11 13:45:12 thread1 [main] - something happened\n这个格式其实是人类可读的日志格式。而 LogFormatter 就是用来定义和控制这个 “格式模板” 的，比如你希望日志长这样：\n2025-06-11 13:37:42 [0ms]  8127    Scheduler_0     99955   [INFO]  [system]        /home/gch/sylar/src/middleware/middleware.cpp:18\n\n\n这就是为什么需要使用 LogFormatter 来格式化。\n\n\n\n\n默认格式\n\n默认格式是%%d&#123;%%Y-%%m-%%d %%H:%%M:%%S&#125;%%T%%t%%T%%N%%T%%F%%T[%%p]%%T[%%c]%%T%%f:%%l%%T%%m%%n\n默认格式描述： 年-月-日 时:分:秒 [累计运行毫秒数] \\\\t 线程id \\\\t 线程名称 \\\\t 协程id \\\\t [日志级别] \\\\t [日志器名称] \\\\t 文件名:行号 \\\\t 日志消息 换行符\n\n\n整体框架\n\nsylar 框架中主要使用 LogFormatter 表示一个日志格式化器。\n\n\n解析\n\n当使用日志格式化器时，其会调用函数 init() ，初始化给定日志格式模板。之后将调用函数 format 用来格式化日志，这就会遍历日志格式化器的成员m_items。由于m_items 存放的是 FormateItem::ptr，而 FormateItem::ptr 是基类指针，所以可以用基类指针来动态调用虚函数，执行的都是派生类对象的方法，所以派生类对象都会执行自己的 format 方法。这就可以将每条 LogEvent 对应的部分交给不同的FormateItem::ptr 来进行格式化输出。\n\n\n主要成员\nstd::string m_pattern;                  // 日志模板格式std::vector&lt;FormateItem::ptr&gt; m_items;  // 用于存放不同的日志处理类bool m_error = false;                   // 用于判断日志模板格式化的时候是否出错\n重要函数\n\ninit()\nvoid LogFormatter::init()&#123;    /**    * @brief    * 简单的状态机判断，提取pattern中的常规字符和模式字符    * 解析的过程就是从头到尾遍历，根据状态标志决定当前字符是常规字符还是模式字符    * 一共有两种状态，即正在解析常规字符和正在解析模板转义字符    */    // 按顺序存储从m_pattern解析到的patterns    std::vector&lt;std::pair&lt;int,std::string&gt;&gt; patterns;    // 判断解析过程是否出错    bool error = false;    // 临时存储常规字符串    std::string temp;    // 存储日期格式的字符串%d&#123;&#125;    std::string date;    // 判断是否在解析常规字符串    bool parse_normal = true;    // 从m_pattern的起始字符串开始    size_t i = 0;    while (i &lt; m_pattern.size())    &#123;        std::string c = std::string(1, m_pattern[i]);        // 首先判断是否是%        if (c == &quot;%&quot;)        &#123;            if (parse_normal)   // 这表示前面一个字符不是%，仍然是普通字符            &#123;                patterns.push_back(std::make_pair(0, temp));                temp.clear();                parse_normal = false;                ++i;                continue;            &#125;            else            &#123;                // 这说明%是转义字符，直接将其添加到patterns                patterns.push_back(std::make_pair(1,&quot;%&quot;));                parse_normal = true;                ++i;                continue;            &#125;        &#125;        else    // 这表示当前字符不是%        &#123;            if (parse_normal)   // 这表示前面一个字符不是%，仍然是普通字符            &#123;                temp += c;                ++i;                continue;            &#125;            else            &#123;                // 这表示是模板字符                patterns.push_back(std::make_pair(1,c));                parse_normal = true;                if (c != &quot;d&quot;)  // 这说明不是日期格式                &#123;                    ++i;                    continue;                &#125;                else                &#123;                    // 这表明是日期格式                    ++i;                    if (i &lt; m_pattern.size() &amp;&amp; m_pattern[i] != &#x27;&#123;&#x27;)                    &#123;                        // 说明格式错误                        continue;                    &#125;                    else                    &#123;                        while (i &lt; m_pattern.size() &amp;&amp; m_pattern[i] != &#x27;&#125;&#x27;)                        &#123;                            date.push_back(m_pattern[i]);                            ++i;                        &#125;                    &#125;                    if (m_pattern[i] != &#x27;&#125;&#x27;)                    &#123;                        // %d后面的大括号没有闭合，直接报错                        std::cout &lt;&lt; &quot;[ERROR] LogFormatter::init() &quot; &lt;&lt; &quot;pattern: [&quot; &lt;&lt; m_pattern &lt;&lt; &quot;] &#x27;&#123;&#x27; not closed&quot; &lt;&lt; std::endl;                        error = true;                        break;                    &#125;                    ++i;                    continue;                &#125;            &#125;        &#125;      &#125;    // 判断是否出错    if (error)    &#123;        m_error = error;        return;    &#125;    // 循环结束完，需要将剩余的字符串也添加到patterns中    if (!temp.empty())    &#123;        patterns.push_back(std::make_pair(0,temp));        temp.clear();    &#125;    // 定义具体的日志处理类，根据日志模板来调用对应的日志处理函数    static std::map&lt;std::string, std::function&lt;FormateItem::ptr(const std::string&amp;)&gt;&gt; s_format_item =    &#123;        &#123;&quot;m&quot;, CreateFormateItem&lt;MessageFormatItem&gt;&#125;,        &#123;&quot;p&quot;, CreateFormateItem&lt;LevelFormatItem&gt;&#125;,        &#123;&quot;c&quot;, CreateFormateItem&lt;LoggerNameFormatItem&gt;&#125;,        &#123;&quot;r&quot;, CreateFormateItem&lt;ElapseFormatItem&gt;&#125;,        &#123;&quot;f&quot;, CreateFormateItem&lt;FileNameFormatItem&gt;&#125;,        &#123;&quot;l&quot;, CreateFormateItem&lt;LineFormatItem&gt;&#125;,        &#123;&quot;t&quot;, CreateFormateItem&lt;ThreadIdFormatItem&gt;&#125;,        &#123;&quot;F&quot;, CreateFormateItem&lt;FiberIdFormatItem&gt;&#125;,        &#123;&quot;N&quot;, CreateFormateItem&lt;ThreadNameFormatItem&gt;&#125;,        &#123;&quot;%&quot;, CreateFormateItem&lt;PercentSignFormatItem&gt;&#125;,        &#123;&quot;T&quot;, CreateFormateItem&lt;TabFormatItem&gt;&#125;,        &#123;&quot;n&quot;, CreateFormateItem&lt;NewLineFormatItem&gt;&#125;    &#125;;    for (auto iterator : patterns)    &#123;        if (iterator.first == 0)        &#123;            // 这是在处理普通的常规字符            m_items.push_back(FormateItem::ptr(new StringFormatItem(iterator.second)));        &#125;        else if (iterator.second == &quot;d&quot;)        &#123;            // 这是在处理日志中的日期            m_items.push_back(FormateItem::ptr(new DateTimeFormatItem(date)));        &#125;        else        &#123;            // 这是在处理模板字符            if (auto it = s_format_item.find(iterator.second); it !=  s_format_item.end())            &#123;                // 这说明能够找到对应模板字符的类                m_items.push_back(it-&gt;second(iterator.second));            &#125;            else            &#123;                // 这表示该字符不是模板字符                std::cout &lt;&lt; &quot;[ERROR] LogFormatter::init() &quot; &lt;&lt; &quot;pattern: [&quot; &lt;&lt; m_pattern &lt;&lt; &quot;] &quot; &lt;&lt; &quot;unknown format item: &quot; &lt;&lt; iterator.second &lt;&lt; std::endl;                error = true;                break;            &#125;        &#125;    &#125;    if(error) &#123;        m_error = true;        return;    &#125;&#125;\n\nformat(LogEvent::ptr event)\nstd::string LogFormatter::format(LogEvent::ptr event)&#123;    std::stringstream ss;    //  遍历具体的日志处理类    for (auto&amp; i: m_items)    &#123;        i-&gt;format(ss, event);    &#125;    return ss.str();&#125;\n\n\n\n5️⃣ 日志输出地\nLogAppender 的作用\n\n在 sylar 框架中，LogAppender 是日志系统中的核心抽象类。它负责将格式化后的日志输出到具体的目标位置（如控制台、文件、远程服务器等）。\n\n\n核心概念\n\n在日志系统中，日志的生成与日志的输出是分离的。LogAppender 就是日志输出端的抽象类，允许我们将同一条日志灵活地输出到多个位置。\n\n\n整体架构\n\n主要成员\nMutexType m_mutex;                   // 互斥量LogFormatter::ptr m_formatter;       // 日志格式化器LogFormatter::ptr defalut_formatter; // 默认日志格式化器\n\n解析\n\nLogAppender 的目的是将向日志根据指定的格式输出到我们想要指定的地方，所以LogAppender 一定会拥有成员 LogFormatter，用于解析日志；同时为了将日志输出到指定地点，我们需要继承 LogAppender，因为我们需要根据想要输出的地点封装不同的类。\n不管是 StdCoutLogAppender 还是 FileLogAppender，都只需要覆写 log 函数，将日志输出到不同的地点。就算我们还想将日志输出到不同的地点，我们只需要继承 LogAppender, 覆写 log 函数就可以了。\n\n\n\n6️⃣ 日志器\nLogger 的职责\n\n通过 LogLevel 管理日志的等级控制\n每个 Logger 对象都有一个等级（如 DEBUG、INFO、WARN、ERROR、FATAL），只会记录大于或等于当前等级的日志。\n\n\n组织多个输出目标（ LogAppender ）\nLogger 并不直接将日志写入文件或控制台，而是将其分发给多个日志输出器（ LogAppender ），这些输出器可以是文件、控制台、远程服务器等。\n\n\n保证线程安全的日志处理流程\n通过互斥锁（如 Spinlock ）保证多线程环境下的安全访问，防止日志混乱或丢失。\n\n\n生成日志元数据\n比如记录日志创建时间（ m_createTime ）、名称（ m_name ）等，方便后期分析与归档。\n\n\n\n\n整体框架\n\n解析\n\n日志器存放了一组日志输出地 LogAppender，当调用函数 log 记录一个日志的时候，如果该日志的等级小于日志器的等级，就会遍历所有的日志输出地，使用日志输出地将其解析并输出到指定的地方。\n\n\n\n7️⃣ 日志事件包装器\nLogEventWrap 的作用\n\n在实现一个高效、灵活的日志系统时，我们往往会设计一个 LogEvent 类来描述一次具体的日志行为，同时用 Logger 类负责将这些事件格式化、输出到终端、文件或远程服务器等目标媒介。\n但在实际开发中，仅靠 LogEvent 和 Logger 可能并不足以满足需求，特别是在使用宏定义简化日志语句的场景下，如何优雅地延迟日志输出、自动触发日志写入成为一个实际问题。\n\n\n整体框架\n\n关键宏定义\n#define SYLAR_LOG_LEVEL(logger,level)\\  if(level &lt;= logger-&gt;getLoggerLevel()) \\  sylar::LogEventWrap(logger, sylar::LogEvent::ptr(new sylar::LogEvent(logger-&gt;getLoggerName(), \\  level, __FILE__, __LINE__, sylar::GetElapsedMS() - logger-&gt;getCreateTime(), \\  sylar::GetThreadId(), sylar::GetFiberId(), time(0), sylar::GetThreadName()))).getLogEvent()-&gt;getSS()  #define SYLAR_LOG_FATAL(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::FATAL)#define SYLAR_LOG_ALERT(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ALERT)            #define SYLAR_LOG_CRIT(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::CRIT)            #define SYLAR_LOG_ERROR(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ERROR)            #define SYLAR_LOG_WARN(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::WARN)            #define SYLAR_LOG_NOTICE(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::NOTICE)            #define SYLAR_LOG_INFO(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::INFO)            #define SYLAR_LOG_DEBUG(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::DEBUG)\n关键函数\n~LogEventWrap() &#123; m_logger-&gt;log(m_event); &#125;\n解析\n\n日志事件包装器主要是将日志事件 LogEvent 和日志器 Logger 结合起来 ！\nLogEventWrap 在构造时持有一个日志器 Logger 和一个日志事件 LogEvent，但并不会立即将日志事件写入日志器。而是在析构时自动调用日志器的 log() 方法，将日志事件正式输出。\n这使得日志语句可以自然地延迟到作用域结束时统一输出。\n\n\n\n8️⃣ 日志器管理类\nLoggerManager 的作用\n\n在构建一个功能完善的日志系统中，我们不仅需要能够生成和输出日志的 Logger 类，还需要一个统一的日志管理中心来组织和协调多个日志器的使用。这就是 LoggerManager 类存在的意义。\n\n\n为什么需要 LoggerManager ?\n\n如果希望为每个模块配置不同的日志器，以便控制它们的日志级别、输出格式、日志文件路径等。这时，如果我们每次都手动创建和维护多个 Logger 实例，不但容易出错，而且很难集中管理。\n\n\n整体框架\n\n\n重要函数\n\ngetLogger()\nLogger::ptr LoggerManager::getLogger(const std::string&amp; name)&#123;    MutexType::Lock lock(m_mutex);        auto it = m_loggers.find(name);    if (it != m_loggers.end())    &#123;        return it-&gt;second;    &#125;    Logger::ptr logger(new Logger(name));    logger-&gt;addAppender(LogAppender::ptr(new StdoutLogAppender));    m_loggers[name] = logger;    return logger;&#125;\n如果在日志器管理类 LoggerManager 中找不到对应名称的日志器 Logger，就自动创建一个对应名称的日志器 Logger，并返回给该日志器。\n\n\n\n解析\n\n在 LoggerManager 的构造函数里，默认都有一个日志器 root，该日志器的日志输出地是控制台 StdCoutAppender，并被注册到了 LoggerManager 的成员日志器集合中 m_loggers。\n\n主要用途在：\n/** *  @brief 获得root日志器 */#define SYLAR_LOG_ROOT() sylar::LoggerMgr::GetInstance()-&gt;getRoot()/** *  @brief 获得指定名称的日志器 */#define SYLAR_LOG_NAME(name) sylar::LoggerMgr::GetInstance()-&gt;getLogger(name)/** *  单例模式的日志管理器  */using LoggerMgr = sylar::SingleTon&lt;LoggerManager&gt;;\n使用单例模式获得 LoggerManager 的实例。\n\n\n9️⃣ 日志模块整体框架图 \n\n\n参考资料：\n\n从零开始重写sylar C++高性能分布式服务器框架\nC++高性能分布式服务器框架\nSylar服务器框架 日志模块 源码分析\n\n","categories":["项目实战","Sylar"],"tags":["sylar","日志系统"]},{"title":"线程模块","url":"/2025/06/14/sylar/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97/","content":"线程模块线程的作用\n在现代 C++ 网络服务器框架中，线程模块是实现并发处理、任务调度和系统资源充分利用的核心组件。Sylar 框架中的线程模块（Thread 类）封装了 POSIX 的 pthread 接口，简化了线程的创建、命名、同步与生命周期管理。\n\n整体框架\n模块解析私有成员变量\nm_name ：当前子线程的名字，在构造函数中我们需要给每一个线程赋予名字。\nm_id ：当前子线程的真实内核级线程ID，Linux 下使用 pid_t 唯一标识一个线程。\nm_thread ：当前子线程的线程标识符，用于表示一个线程对象。\nm_cb ：当前子线程绑定的回调函数，同样在构造函数中需要给每一个线程赋予它们所需要执行的函数\nm_semphore ：当前子线程的信号量，用于进行子线程和主线程之间的同步。\n\n重要成员函数\n构造函数\nThread::Thread(std::function&lt;void()&gt; cb, const std::string &amp;name)    : m_cb(cb)    , m_name(name)&#123;    if (name.empty())    &#123;        m_name = &quot;UNKNOWN&quot;;    &#125;    int rt = pthread_create(&amp;m_thread, nullptr, &amp;Thread::run, this);    if (rt)    &#123;        SYLAR_LOG_ERROR(g_logger) &lt;&lt; &quot;pthread create thread fail , rt=&quot; &lt;&lt; rt &lt;&lt; &quot;name=&quot;&lt;&lt; name;        throw std::logic_error(&quot;pthread create error&quot;);    &#125;    m_semaphore.wait();&#125;\n\n参数解析\ncb ：当前子线程绑定的回调函数。\nname ：当前子线程的名称。\n\n\n函数解析\n通过调用系统API pthread_create ，创建一个子线程，并将该线程的执行函数设置为 Thread 类中的静态函数 run，同时将指向当前对象的指针 this 作为参数进行传入。之后，新线程的 ID 被保存在成员变量 m_thread 中。\n与此同时，主线程执行 m_semaphore.wait() 等待子线程进行线程的初始化以及完成对应的回调函数。\n\n\n\n\n析构函数 ~Thread()\n  Thread::~Thread()&#123;    if (m_thread)    &#123;        pthread_detach(m_thread);    &#125;   &#125;\n\n\n函数解析\n如果主线程已经要结束了，但是子线程仍然存在，就子线程设置为分离线程。这表示主线程不会去调用 pthread_join 来等待它退出。\n\n\n\n\nrun\n  void* Thread::run(void* arg)&#123;    Thread* thread = (Thread*)(arg);    t_thread = thread;    t_thread_name = thread-&gt;m_name;    thread-&gt;m_id = sylar::GetThreadId();    pthread_setname_np(pthread_self(), thread-&gt;m_name.substr(0, 15).c_str());        std::function&lt;void()&gt; cb;    cb.swap(thread-&gt;m_cb);    thread-&gt;m_semaphore.notify();    cb();    return 0;&#125;\n\n参数解析\narg ：void* 标识可以接收任意类型的指针参数，在此刻 void* 主要接受的是构造函数里 pthread_create 传入的 this 指针，即 Thread*。\n\n\n函数解析\nt_thread 的类型是静态线程局部变量 Thread*。\nthread_local 表示每个线程都有对当前变量的副本，即每个线程对线程变量都是独立的，不会相互干扰。\n由于每个 Thread 传入的参数都是 this 指针（指向自己的指针）。所以 t_thread 保存的都是当前的 Thread 对象的指针。t_thread_name 保存的是当前 Thread 对象的名称。之后，指针 thread 设置当前 Thread 的线程 id，通过系统 API 设置当前线程的名称。最后，通过信号量 m_semphore 唤醒当时等待在构造函数里的主线程，然后子线程执行完回调函数 cb 就终止了。\n\n\n\n\nGetThis\n  static thread_local Thread* t_thread = nullptr;...Thread* Thread::GetThis()&#123;    return t_thread;&#125;\n\n函数解析\n可知 t_thread 保存的就是当前 Thread 对象的指针。\n函数 GetThis() 返回当前线程所对应的 Thread 对象指针。\n\n\n\n\nGetName\n  const std::string&amp; Thread::GetName()&#123;    return t_thread_name;&#125;\n\n函数解析\n可知 t_thread_name 保存的就是当前 Thread 对象的名字。\n函数 GetName() 返回当前线程所对应的 Thread 对象的名字。\n\n\n\n\n\n线程同步模块线程同步的作用\n线程同步的作用主要在于保证多线程环境下对共享资源的安全访问，防止出现数据竞争、死锁、脏读等问题，从而确保程序行为的正确性和一致性。\n\n为什么需要线程同步\n数据竞争（Race Condition）：多个线程并发访问同一个资源，读写操作交叉执行，导致数据状态不一致。\n脏读&#x2F;写：一个线程正在写数据，另一个线程同时读取，读到的是未完成或错误的中间状态。\n死锁（Deadlock）：两个或多个线程互相等待对方释放资源，导致程序无法继续执行。\n\n信号量\nSemphore 的作用\n\n信号量（Semaphore）是一个计数器，用于控制对某个共享资源的访问数量，实现线程之间的同步与互斥。\n\n\n基本原理\n\n信号量维护一个整型计数器 count : \n当线程执行 wait()（P 操作）：\n如果 count &gt; 0，则将 count–，允许线程继续执行；\n如果 count &#x3D;&#x3D; 0，线程会阻塞等待资源可用。\n\n\n当线程执行 notify()（V 操作）： \n将 count++，表示释放一个资源；\n如果有线程在等待，将唤醒其中一个。\n\n\n\n\n\n\n整体框架\n  \n\n函数解析\n\n构造函数\nSemaphore::Semaphore(uint32_t count)&#123;    if (sem_init(&amp;m_semaphore, 0, count))    &#123;        throw std::logic_error(&quot;sem_init error&quot;);    &#125;&#125;\n析构函数\nSemaphore::~Semaphore()&#123;    sem_destroy(&amp;m_semaphore);    &#125;    \n\nwait \nvoid Semaphore::wait()&#123;    if (sem_wait(&amp;m_semaphore))    &#123;        throw std::logic_error(&quot;sem_wait error&quot;);    &#125;&#125;\nnotify\nvoid Semaphore::notify()&#123;    if (sem_post(&amp;m_semaphore))    &#123;        throw std::logic_error(&quot;sem_post error&quot;);    &#125;&#125;\n\n\n\n互斥量\nMutex 的作用\n\n互斥量（ Mutex ）是一种用于线程间互斥访问共享资源的同步原语。它保证同一时间只有一个线程可以访问某段临界区（critical section）代码或共享资源。\n\n\n为什么需要 Mutex\n\n防止多线程同时访问共享资源造成数据竞态（Race Condition）。\n多个线程并发访问共享资源（如变量、文件、数据库）时，如果不加保护，会出现不可预测的错误。互斥量能防止这种情况。\n\n\n保证临界区代码的线程安全\n在临界区（修改共享变量的代码段）前加锁，退出时解锁，保证任何时刻最多只有一个线程运行这段代码。\n\n\n\n\n基本原理\n\n加锁（ lock ）\n如果没有被锁定，当前线程获得锁，继续执行；\n如果已被锁定，当前线程将阻塞直到获得锁。\n\n\n解锁( unlock )\n释放锁，如果有阻塞线程，会唤醒其中一个。\n\n\n\n\n整体框架\n  \n\n函数解析\n\n构造函数\nMutex()&#123;    pthread_mutex_init(&amp;mutex, nullptr);&#125;\n\n析构函数\n~Mutex()&#123;    pthread_mutex_destroy(&amp;mutex);&#125;\n\nlock\nvoid lock()&#123;    pthread_mutex_lock(&amp;mutex);&#125;\n\nunlock\nvoid unlock()&#123;    pthread_mutex_unlock(&amp;mutex);&#125;\n\n\n\n读写锁\nRWMutex 的作用\n\n读写锁是一种高级同步原语，适用于：读多写少 的共享资源访问场景。它允许多个线程同时读取（读锁共享）以及写操作时独占访问（写锁互斥）。\n\n\n为什么需要 RWMutex\n\n支持高并发读\n多个线程可以同时加读锁，避免阻塞，从而提升读取性能。\n\n\n写操作安全\n当一个线程加写锁时，会阻塞其他所有的读锁或写锁请求，确保写操作的原子性和一致性。\n\n\n适用于读多写少的共享资源\n\n\n基本原理\n\n基本状态变量\nint readers = 0;          // 当前持有读锁的线程数int writers = 0;          // 当前持有写锁的线程数（最多为1）int write_requests = 0;   // 正在等待获取写锁的线程数std::mutex mtx;           // 内部互斥锁保护状态变量std::condition_variable reader_cv;std::condition_variable writer_cv;\n\n加读锁（读线程调用）\nlock(mtx);while (writers &gt; 0 || write_requests &gt; 0) &#123;    reader_cv.wait(mtx);   // 等待写线程释放或避免饿死写线程&#125;readers++;unlock(mtx);\n\n加写锁（写线程调用）\nlock(mtx);write_requests++;while (readers &gt; 0 || writers &gt; 0) &#123;    writer_cv.wait(mtx);   // 等待所有读和写线程释放锁&#125;write_requests--;writers = 1;unlock(mtx);\n\n解锁\nlock(mtx);if (当前线程是读锁) &#123;    readers--;    if (readers == 0 &amp;&amp; write_requests &gt; 0)        writer_cv.notify_one();  // 唤醒写线程&#125;else &#123;  // 写锁    writers = 0;    if (write_requests &gt; 0)        writer_cv.notify_one();  // 写优先    else        reader_cv.notify_all();  // 唤醒所有读线程&#125;unlock(mtx);\n\n\n整体框架\n  \n\n函数解析\n  class RWMutex : Noncopyable&#123;public:    using ReadLock = ReadScopedLockImpl&lt;RWMutex&gt;;    using WriteLock = WriteScopedLockImpl&lt;RWMutex&gt;;    RWMutex()    &#123;        pthread_rwlock_init(&amp;m_lock,nullptr);    &#125;    ~RWMutex()    &#123;        pthread_rwlock_destroy(&amp;m_lock);    &#125;    void rdlock()    &#123;        pthread_rwlock_rdlock(&amp;m_lock);    &#125;    void wrlock()    &#123;        pthread_rwlock_wrlock(&amp;m_lock);    &#125;    void unlock()    &#123;        pthread_rwlock_unlock(&amp;m_lock);    &#125;private:    pthread_rwlock_t m_lock;    // 读写锁&#125;;\n\n","categories":["项目实战","Sylar"],"tags":["sylar","线程模块"]},{"title":"配置模块","url":"/2025/06/12/sylar/%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97/","content":"配置模块配置模块的作用\n统一管理配置项：通过集中式管理配置项，避免硬编码，便于维护与管理。\n支持多种类型配置：包括基础类型（如 int, string）、容器类型（如 vector, map）、以及自定义类型（如 CorsConfig）。\n支持 YAML 配置文件解析：便于配置文件的可读性和层级表达。\n支持运行时动态更新：变更配置项时触发回调函数，便于系统感知配置变更。\n\n配置项基类\n整体架构\n\n\n解析\n\nConfigVarBase 是所有配置的基类，它主要有两个成员变量 m_name 和 m_description 。前者便是每个配置都应该有的名称，后者表示对该配置的描述\nConfigVarBase 主要包含三个虚函数：toString()，fromString()，getTypeName()，用于给配置子类进行继承。前两个虚函数 toString()和fromString()主要用于配置子类的序列化和反序列化，而后者的 getTypeName() 用于返回配置子类的类型。\n\n\n\n类型转换模板类\nlexicalCast 的作用\n实现通用类型之间的转换，例如：\n将（配置文件内容） YAML 字符串转换成某个具体的类型LexicalCast&lt;std::string, int&gt; cast;int val = cast(&quot;123&quot;);\n将某个类型转成 YAML 字符串（用于序列化配置）LexicalCast&lt;int, std::string&gt; cast;std::string str = cast(456); \n支持复杂类型，如 vector&lt;T&gt;、map&lt;string, T&gt; 等：可以通过模板特例化实现自定义转换逻辑，例如用 YAML 库处理容器类型。\n\n\n\n\n案例解析\n接下来，我将分析一组例子，使得大家对类型转换模板类的理解更加的透彻。\n/*** @brief 类型转换模板类偏特化(YAML String 转换成 std::vector&lt;T&gt;)*/template&lt;class T&gt;class lexicalCast&lt;std::string, std::vector&lt;T&gt;&gt;&#123;public:    std::vector&lt;T&gt; operator() (const std::string&amp; val)    &#123;        YAML::Node node = YAML::Load(val);        typename std::vector&lt;T&gt; vec;        std::stringstream ss;        for(size_t i = 0; i &lt; node.size(); ++i)        &#123;            ss.str(&quot;&quot;);            ss &lt;&lt; node[i];            vec.push_back(lexicalCast&lt;std::string, T&gt;()(ss.str()));        &#125;        return vec;    &#125;&#125;;\n\n在上述例子中，它主要的作用是：将一个 YAML 格式的字符串转换为 std::vector&lt;T&gt; 类型。\n什么是 YAML 格式的字符串：\n比如：简单的整数数组ports: [8001, 8002, 8003]\n等价在 C++ 中传入的字符串形式就是std::string val = &quot;[8001, 8002, 8003]&quot;;\n这样通过 YAML::Node() 函数就可以将字符串 val 转换成 Node 结点，通过Node 结点，就可以将结点的内容全部输出到我们字节流中，最后转换成我们想要的类型。\n\n\n\n\n同理，将 vector&lt;T&gt; 转换成 std::string 就是相反的操作\ntemplate&lt;class T&gt;class lexicalCast&lt;std::vector&lt;T&gt;, std::string&gt;&#123;public:    std::string operator()(const std::vector&lt;T&gt; vec)    &#123;        YAML::Node node(YAML::NodeType::Sequence);        for(auto&amp; i : vec)        &#123;            node.push_back(YAML::Load(lexicalCast&lt;T, std::string&gt;()(i)));        &#125;        std::stringstream ss;        ss &lt;&lt; node;        return ss.str();    &#125;    &#125;;\n\n现在我们想把一个 std::vector&lt;T&gt; 变成 YAML 字符串，比如：\n  std::vector&lt;int&gt; v = &#123;1, 2, 3&#125;;\n  转换后的结果\n  [1, 2, 3]\n而使用 YAML::Load(...) 是为了确保\n\n字符串 &quot;1&quot; 被当作 数字 1，而不是字符串 &quot;1&quot;\n字符串 &quot;&#123;x: 1, y: 2&#125;&quot; 被当作一个映射，而不是普通字符串\n字符串 &quot;[1, 2]&quot; 被当作数组，而不是字符串\n\n\n\n\n\n\n\n配置子类\nConfigvar 的作用\n\nConfigVar 是一个模板类，属于配置系统中的核心组件，它的职责是：封装一个类型为 T 的配置变量，并提供\n类型安全的访问接口\n支持 YAML 字符串和变量间的双向转换\n支持配置变更时触发监听器回调\n统一管理和注册\n\n\n它继承自抽象基类 ConfigVarBase，用于实现多态存储。\n通过结合 lexicalCast 类型转换模板类，ConfigVar 实现了任何可序列化类型的灵活支持。\n\n\n整体框架\n\n\n解析\n\n成员变量T m_value;std::unordered_map&lt;uint64_t, on_change_cb&gt; m_cbs;\n\nm_value 是当前配置的值\nm_cbs 是监听器集合，支持注册多个回调，每个变化都会触发对应函数。\n\n\n重要函数\ntoString()\n在 ConfigVar&lt;T&gt; 类中，我们希望能够支持任意类型 T 的配置参数将其序列化为 YAML 字符串形式，比如将一个 int、一个 std::vector&lt;int&gt; 甚至是 std::map&lt;string, T&gt; 转成 YAML 格式的字符串。\n为了做到这一点，toString() 并不硬编码转换逻辑，而是通过一个策略类 ToStr 来完成转换。这个 ToStr 实际上是一个 仿函数（函数对象），你可以把它理解为可以 “像函数一样使用的类”。\n核心代码std::string toString() override &#123;try &#123;    return ToStr()(m_value); &#125;...&#125;\n这里的 ToStr()(m_value) 表示：创建一个 ToStr 类型的对象（默认为 lexicalCast&lt;T, std::string&gt;）；然后调用它的 operator()，将 m_value 转换为 std::string。\n流程图\n        ConfigVar::toString() \n                    ↓ \n        调用 ToStr()(m_value) \n                    ↓ \n        lexicalCast::operator()(const T& val) \n                    ↓ \n        返回 YAML 格式的字符串\n\n\n\nfromString()\n在 ConfigVar&lt;T&gt; 类中，我们同样希望能够将一个 YAML 字符串形式的配置值反序列化成任意类型 T，例如从 &quot;10&quot; 恢复成 int，从 &quot;[1, 2, 3]&quot; 恢复成 std::vector&lt;int&gt;，甚至从复杂 YAML 字符串恢复成 std::map、std::set 等容器。\n为了做到这一点，fromString() 并不直接写死转换逻辑，而是通过一个策略类 FromStr 来完成解析转换。这个 FromStr 本质上也是一个仿函数（函数对象），默认定义为 lexicalCast&lt;std::string, T&gt;。\n核心代码：bool fromString(const std::string&amp; val) override &#123;    try     &#123;        setValue(FromStr()(val));    &#125;     catch (const std::exception&amp; e)     &#123;        SYLAR_LOG_ERROR(...) &lt;&lt; &quot;exception: &quot; &lt;&lt; e.what();    &#125;    return false;&#125;\n这里的 FromStr()(val) 表示：创建一个 FromStr 类型的对象；调用其 operator()，将字符串 val 转换为类型 T；成功后通过 setValue() 更新当前配置值。\n流程图\n        ConfigVar::fromString(val) \n                    ↓ \n            调用 FromStr()(val) \n                    ↓ \nlexicalCast::operator()(const std::string& val) \n                    ↓ \n            返回类型为 T 的值 \n                    ↓ \n        setValue() 更新配置项的值 \n\n\n\n\n\n\n\n\n配置管理类\nConfigVarMap 的作用\n\n存储配置项\nConfigVarMap以 key-value 的形式存储程序中的配置变量，方便统一管理\n\n\n统一访问入口\n通过 ConfigVarMap，程序中任何模块都能方便地读取或修改配置项，保证配置的集中和一致性。\n\n\n动态更新配置\n支持在程序运行时动态加载和修改配置，比如从配置文件读取，实时生效。\n\n\n监听配置变化\n有些实现支持监听配置项的变化，变更时自动触发回调，方便做动态调整。\n\n\n\n\n整体架构\n\n\n关键函数解析\n\nGetDatas\nstatic ConfigVarMap&amp; GetDatas()&#123;    static ConfigVarMap s_datas;    return s_datas;&#125;\nConfigVarMap 被定义为 std::unordered_map&lt;std::string, ConfigVarBase::ptr&gt;，主要用来查找配置变量的名字来获得对应的配置变量。\n\nLookup\ntemplate&lt;class T&gt;static typename ConfigVar&lt;T&gt;::ptr Lookup(const std::string&amp; name, const std::string&amp; description, const T&amp; val)&#123;    auto it = GetDatas().find(name);    if (it != GetDatas().end())    &#123;        auto tmp = std::dynamic_pointer_cast&lt;ConfigVar&lt;T&gt;&gt;(it-&gt;second);        if (tmp)        &#123;            SYLAR_LOG_INFO(SYLAR_LOG_ROOT()) &lt;&lt; &quot;Lookup name= &quot; &lt;&lt; name &lt;&lt; &quot;exists&quot;;            return tmp;        &#125;        else        &#123;            SYLAR_LOG_ERROR(SYLAR_LOG_ROOT()) &lt;&lt; &quot;Lookup name= &quot; &lt;&lt; name &lt;&lt; &quot; exists but type not&quot;                                             &lt;&lt; TypeToName&lt;T&gt;() &lt;&lt; &quot; real type=&quot; &lt;&lt; it-&gt;second-&gt;getTypeName()                                             &lt;&lt;&quot; &quot; &lt;&lt; it-&gt;second-&gt;toString();        &#125;    &#125;    if (name.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz._0123456789&quot;) != std::string::npos)    &#123;        SYLAR_LOG_ERROR(SYLAR_LOG_ROOT()) &lt;&lt; &quot;Lookup name invalid &quot; &lt;&lt; name;        throw std::invalid_argument(name);    &#125;    typename ConfigVar&lt;T&gt;::ptr newConfigVar(std::make_shared&lt;ConfigVar&lt;T&gt;&gt;(name,description,val));    GetDatas()[name] = newConfigVar;    return newConfigVar;&#125;\n\n该函数主要用来寻找是否有对应名称的参数，如果没有就创建配置参数。\n\nListAllMember\nstatic void ListAllMember(const std::string&amp; prefix,                        const YAML::Node&amp; node,                        std::list&lt;std::pair&lt;std::string, const YAML::Node&gt;&gt;&amp; output)&#123;    if (prefix.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz._0123456789&quot;)                 != std::string::npos)    &#123;        SYLAR_LOG_ERROR(SYLAR_LOG_ROOT()) &lt;&lt; &quot;Config invaild name : &quot;&lt;&lt; prefix &lt;&lt; &quot; : &quot; &lt;&lt; node;        return;    &#125;    output.push_back(std::make_pair(prefix, node));    if (node.IsMap())    &#123;        for (auto it = node.begin(); it != node.end(); ++it)        &#123;            ListAllMember(prefix.empty() ? it-&gt;first.Scalar() : prefix + &quot;.&quot; + it-&gt;first.Scalar(), it-&gt;second, output);        &#125;            &#125;    &#125;\n\n\n函数作用\n该函数主要用于递归遍历 YAML 配置文件节点。\n\n\n参数解析\nprefix：当前节点路径前缀\nnode：当前 YAML 节点\noutput：存储遍历结果，每个 pair 是一个“路径名-节点”的组合。\n\n\n函数解析\n先要判断 prefix 没有非法字符，防止路径名不合法。之后，如果 yaml 字符串不是 Map 类型，就直接将配置名称和配置的值作为 pair 输入到 output。否则，递归处理 Yaml Map类型，遍历其所有子项。it-&gt;first.Scalar() 是 key，it-&gt;second 是 value。通过构造新的路径 new_prefix &#x3D; prefix + “.” + 子节点名递归调用自己，继续往下遍历子节点。\n\n\n例子server:  port: 8080  host: 127.0.0.1database:  user: root  password: pass\n遍历后 output 中将包含：(&quot;server&quot;, &lt;Node&gt;)(&quot;server.port&quot;, 8080)(&quot;server.host&quot;, &quot;127.0.0.1&quot;)(&quot;database&quot;, &lt;Node&gt;)(&quot;database.user&quot;, &quot;root&quot;)(&quot;database.password&quot;, &quot;pass&quot;)\n\n\nLoadFromYaml\nvoid Config::LoadFromYaml(const YAML::Node&amp; root)&#123;    std::list&lt;std::pair&lt;std::string, const YAML::Node&gt;&gt; all_nodes;    ListAllMember(&quot;&quot;,root,all_nodes);      for (auto&amp; i : all_nodes)    &#123;        std::string key = i.first;        if (key.empty())        &#123;            continue;        &#125;        std::transform(key.begin(), key.end(), key.begin(), ::tolower);        ConfigVarBase::ptr var = LookupBase(key);        if (var)        &#123;            if (i.second.IsScalar())            &#123;                var-&gt;fromString(i.second.Scalar());            &#125;            else            &#123;                std::stringstream ss;                ss &lt;&lt; i.second;                var-&gt;fromString(ss.str());            &#125;        &#125;            &#125;&#125;\n\n作用\n将 YAML 配置文件中的数据，加载并解析为对应的配置变量（ConfigVarBase）实例的值。\n\n\n参数解析\nroot：是一个 YAML 的根节点，通常来自 YAML::Load() 解析出来的配置树。\n\n\n函数解析\n调用 ListAllMember() 把整个 YAML::Node 展开成一系列路径 + 值，保存到 all_nodes 列表中。\nfor (auto&amp; i : all_nodes) 遍历每个键值对，尝试赋值。\n查找是否注册了这个 key 的变量（如 system.port），如果没有注册，则跳过（只加载已注册的配置项）\n最后解析 YAML 值并赋值。如果是标量（如 “myserver“、8080 等），直接调用 Scalar() 转字符串。如果是复杂类型（如 list、map ），则将整个 YAML::Node 流式输出为字符串，再传入 fromString()。\n\n\n\n\nVisit\nvoid Config::Visit(std::function&lt;void(ConfigVarBase::ptr)&gt; cb) &#123;    RWMutexType::ReadLock lock(GetMutex());    ConfigVarMap&amp; m = GetDatas();    for(auto it = m.begin();it != m.end(); ++it)     &#123;        cb(it-&gt;second);    &#125;&#125;\n\n作用\n遍历所有配置项（已注册的 ConfigVarBase 派生对象），对每个变量执行传入的回调函数 cb。\n\n\n参数解析\nstd::function&lt;void(ConfigVarBase::ptr)&gt; 就是对每个变量执行传入的回调函数。\n\n\n函数解析\nRWMutexType::ReadLock：这是一个读写锁的读锁（Read Lock），可让多个线程同时读取配置数据。\nGetMutex()：返回用于保护配置数据的静态全局读写锁\n遍历每一个 std::pair&lt;std::string, ConfigVarBase::ptr&gt;。执行传入的 cb() 函数，参数是该配置变量对象。\n\n\n例子sylar::Config::Visit([](ConfigVarBase::ptr var) &#123;std::cout &lt;&lt; &quot;name=&quot; &lt;&lt; var-&gt;getName()          &lt;&lt; &quot; description=&quot; &lt;&lt; var-&gt;getDescription()          &lt;&lt; &quot; type=&quot; &lt;&lt; var-&gt;getTypeName()          &lt;&lt; std::endl;&#125;);\n输出结果name=system.port description=system port type=intname=system.name description=system name type=string\n\n\n\n\n\n整体框架图  \n参考资料：\n\n从零开始重写sylar C++高性能分布式服务器框架\nC++高性能分布式服务器框架\nSylar服务器框架 配置模块 源码分析\n\n","categories":["项目实战","Sylar"],"tags":["sylar","配置模块"]}]